#!/usr/bin/env python3
from pwn import *

context.log_level = 'info'
context.arch = 'i386'

def make_io():
    return process('./empty_read')

def send_num(r, n):
    """Send a number as 4 bytes for read()"""
    r.send(str(n).encode().ljust(4, b'\n')[:4])

def cmd(r, c):
    r.recvuntil(b'Enter command:')
    r.sendline(c)

def add(r, idx, length, email):
    cmd(r, b'add')
    r.recvuntil(b'User index to add:')
    send_num(r, idx)
    r.recvuntil(b'User email length:')
    send_num(r, length)
    r.recvuntil(b'User email:')
    actual_len = length if 0 < length <= 0x200 else 0x200
    r.send(email.ljust(actual_len, b'\x00')[:actual_len])

def edit(r, idx, email, length):
    cmd(r, b'edit')
    r.recvuntil(b'User index to edit:')
    send_num(r, idx)
    r.recvuntil(b'User email:')
    r.send(email.ljust(length, b'\x00')[:length])

def delete(r, idx):
    cmd(r, b'delete')
    r.recvuntil(b'User index to delete:')
    send_num(r, idx)

def show(r):
    cmd(r, b'print')
    data = r.recvuntil(b'Enter command:', drop=True)
    return data

r = make_io()

# Test: Create and delete multiple allocations
log.info("Creating users 0, 1, 2")
add(r, 0, 0x18, b"AAAA")
add(r, 1, 0x18, b"BBBB")  
add(r, 2, 0x80, b"CCCC")  # Different size

log.info(show(r).decode())

# Delete in sequence
log.info("Deleting user 0 then 1")
delete(r, 0)
delete(r, 1)

# Now add new user - tcache should reuse chunks
log.info("Adding user 3 with size 0x18")
add(r, 3, 0x18, b"XXXX")

log.info("Adding user 4 with size 0x18")
add(r, 4, 0x18, b"YYYY")

log.info(show(r).decode())

# Check: The struct and email might have overlapping allocations
# With tcache, chunks of same size go to same bin

r.sendline(b'exit')
r.close()
log.success("Basic test done")
