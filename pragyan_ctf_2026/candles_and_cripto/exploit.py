#!/usr/bin/env python3
"""
Candles and Crypto - Exploit Final
Pragyan CTF 2026

Técnica: Polynomial Hash Zero → Signature Forgery
g(x,a,b) = x(x^2 + ax + b) mod P

Si x ≡ 0 (mod P) → h = 0 → sig = 0 pasa verificación RSA
Porque 0^e mod n = 0 para cualquier e

Flag: p_ctf{3l0w-tH3_c4Ndl35.h4VE=-tHe_CaK3!!}
"""
import os
import time
from Crypto.Util.number import bytes_to_long
from pwn import *

context.log_level = 'info'

P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF61  # Prime: 2^128 - 159

B = b"I authorize the transaction:\n"  # 29 bytes
SUFFIX_LEN = 48

def find_suffix():
    """
    Brute force para encontrar suffix de 48 bytes (ASCII printable)
    tal que bytes_to_long(p(B + suffix)) ≡ 0 (mod P)

    Estrategia:
    - Fijar 32 bytes superiores aleatorios
    - Calcular los 16 bytes inferiores que hacen x ≡ 0 (mod P)
    - Verificar que los 16 bytes sean printable ASCII
    """
    padding_byte = bytes([(len(B) + SUFFIX_LEN) & 0xFF])  # b'M' (77)

    log.info(f"Buscando suffix donde x ≡ 0 (mod P)...")
    log.info(f"P = {hex(P)}")
    log.info(f"Estrategia: Fijar 32 bytes superiores, calcular 16 inferiores")

    shift = pow(256, 17, P)  # 256^17 mod P

    attempts = 0
    start = time.time()

    while True:
        # Generar 32 bytes superiores aleatorios (printable ASCII: 33-126)
        upper = bytes([33 + (b % 94) for b in os.urandom(32)])

        high = bytes_to_long(B + upper)
        target = (-high * shift) % P  # Valor que deben tener los 17 bytes bajos

        # target = bytes_to_long(suffix_lower(16) + padding_byte)
        # suffix_lower_int = (target - ord('M')) / 256
        suffix_lower_int = ((target - padding_byte[0]) * pow(256, -1, P)) % P

        # Verificar que cabe en 16 bytes
        if suffix_lower_int >= 256**16:
            attempts += 1
            continue

        # Convertir a 16 bytes big-endian
        try:
            lower = suffix_lower_int.to_bytes(16, 'big')
        except:
            attempts += 1
            continue

        # Verificar printabilidad (ASCII 32-126)
        if all(32 <= c <= 126 for c in lower):
            suffix = upper + lower
            elapsed = time.time() - start

            log.info(f"Suffix encontrado en {attempts:,} intentos ({elapsed:.1f}s)")
            log.info(f"Rate: {attempts/elapsed:,.0f} intentos/s")
            log.info(f"Suffix: {suffix}")

            # Verificación
            msg = B + suffix
            padded = msg + padding_byte
            x = bytes_to_long(padded)

            if x % P == 0:
                log.info("Verificación: x mod P = 0")
                return suffix
            else:
                log.error(f"ERROR: x mod P = {x % P} (debería ser 0)")
                continue

        attempts += 1

        if attempts % 1_000_000 == 0:
            elapsed = time.time() - start
            rate = attempts / elapsed
            log.info(f"{attempts/1e6:.1f}M intentos ({rate:,.0f}/s) [{elapsed:.0f}s]")

def exploit():
    """
    Exploit completo: encuentra suffix y lo envía al servidor
    """
    log.info("Candles and Crypto - Polynomial Zero Attack")

    # Paso 1: Encontrar suffix válido
    suffix = find_suffix()

    if not suffix:
        log.error("No se pudo encontrar suffix válido")
        return

    # Guardar suffix para referencia
    with open('/tmp/candles_suffix.bin', 'wb') as f:
        f.write(suffix)
    log.info("Suffix guardado en /tmp/candles_suffix.bin")

    # Paso 2: Conectar al servidor
    log.info("\nConectando a candles.ctf.prgy.in:1337...")

    try:
        io = remote('candles.ctf.prgy.in', 1337, ssl=True)

        # Esperar menú
        io.recvuntil(b'> ')

        # Opción 2: Execute transaction
        log.info("Enviando opción 2 (Execute transaction)...")
        io.sendline(b'2')

        # Enviar suffix
        io.recvuntil(b'Suffix:')
        log.info(f"Enviando suffix ({len(suffix)} bytes)...")
        io.sendline(suffix)

        # Enviar firma = 0
        io.recvuntil(b'Signature:')
        log.info("Enviando firma = 0 (porque h = 0)...")
        io.sendline(b'0')

        # Recibir respuesta
        response = io.recvall(timeout=5).decode()

        log.info("\nRespuesta del servidor:")
        print(response)

        # Buscar flag
        if 'p_ctf{' in response:
            flag = response[response.find('p_ctf{'):response.find('}', response.find('p_ctf{'))+1]

            log.info(f"\nFlag: {flag}")

            # Guardar flag
            try:
                with open('/root/ctf/flags.txt', 'a') as f:
                    f.write(f"Candles and Crypto (verified): {flag}\n")
                log.info("Flag guardada en /root/ctf/flags.txt")
            except:
                pass

        io.close()

    except Exception as e:
        log.error(f"Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    exploit()
