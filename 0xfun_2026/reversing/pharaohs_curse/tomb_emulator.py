#!/usr/bin/env python3
"""
Emulator for the tomb_guardian VM
"""

# Bytecodes extracted from 0x4040
bytecode = bytes([
    0x40, 0x01, 0xaa, 0x12, 0x01, 0x9a, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0xbb, 0x12, 0x01, 0xcb, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0xcc, 0x12, 0x01, 0xff, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0xdd, 0x12, 0x01, 0xb3, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0xee, 0x12, 0x01, 0xb1, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x11, 0x12, 0x01, 0x62, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x22, 0x12, 0x01, 0x11, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x33, 0x12, 0x01, 0x40, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x44, 0x12, 0x01, 0x70, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x55, 0x12, 0x01, 0x38, 0x20, 0x31, 0x91, 0x02,
    0x40, 0x01, 0x66, 0x12, 0x01, 0x55, 0x20, 0x31, 0x91, 0x02,
    # After the initial checks (offset 0x6e from start):
    0x01, 0x2c, 0x01, 0x2d, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x3a, 0x01, 0x3b, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x30, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x3b, 0x01, 0x3b, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x38, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x35, 0x01, 0x36, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x37, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x3a, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x36, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x3a, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x37, 0x10, 0x41,
    0x01, 0x33, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x3a, 0x01, 0x3b, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x3b, 0x01, 0x3c, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x36, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x36, 0x10, 0x41,
    0x01, 0x16, 0x01, 0x16, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x37, 0x10, 0x41,
    0x01, 0x3c, 0x01, 0x3d, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x31, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x35, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x36, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x17, 0x01, 0x17, 0x10, 0x41,
    0x01, 0x17, 0x01, 0x17, 0x10, 0x41,
    0x01, 0x17, 0x01, 0x17, 0x10, 0x41,
    0x01, 0x05, 0x01, 0x05, 0x10, 0x41,
    0x01, 0x2a, 0x01, 0x2a, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x30, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x31, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x39, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x31, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x30, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x37, 0x10, 0x41,
    0x01, 0x31, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x33, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x39, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x30, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x3b, 0x01, 0x3c, 0x10, 0x41,
    0x01, 0x30, 0x01, 0x31, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x35, 0x10, 0x41,
    0x01, 0x3a, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x1d, 0x01, 0x1d, 0x10, 0x41,
    0x01, 0x10, 0x01, 0x10, 0x10, 0x41,
    0x01, 0x25, 0x01, 0x26, 0x10, 0x41,
    0x01, 0x34, 0x01, 0x34, 0x10, 0x41,
    0x01, 0x19, 0x01, 0x1a, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x38, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x3a, 0x10, 0x41,
    0x01, 0x2f, 0x01, 0x30, 0x10, 0x41,
    0x01, 0x28, 0x01, 0x28, 0x10, 0x41,
    0x01, 0x3c, 0x01, 0x3d, 0x10, 0x41,
    0x01, 0x39, 0x01, 0x39, 0x10, 0x41,
    0x01, 0x1a, 0x01, 0x1a, 0x10, 0x41,
    0x01, 0x36, 0x01, 0x37, 0x10, 0x41,
    0x01, 0x18, 0x01, 0x19, 0x10, 0x41,
    0x01, 0x32, 0x01, 0x32, 0x10, 0x41,
    0x01, 0x05, 0x01, 0x05, 0x10, 0x41,
    0xfe, 0x01, 0x27, 0x01, 0x27, 0x10, 0x41,
    0x01, 0x37, 0x01, 0x38, 0x10, 0x41,
    0x01, 0x17, 0x01, 0x17, 0x10, 0x41,
    0xff
])

# Verify length
print(f"[*] Bytecode length: {len(bytecode)} (expected 0x2a4 = {0x2a4})")

class VM:
    def __init__(self, bytecode, input_bytes=b''):
        self.bytecode = bytecode
        self.regs = [0] * 8          # r0-r7
        self.mem = [0] * 256          # memory at rdi+8
        self.stack = [0] * 256        # stack at rdi+0x108
        self.sp = 0                   # stack pointer
        self.ip = 0                   # instruction pointer
        self.halt = False
        self.exit_code = 0
        self.input_buf = list(input_bytes)
        self.output = []
        self.xor_global = 0           # [0x4b19]
        self.max_ip = len(bytecode)

    def push(self, val):
        self.stack[self.sp] = val & 0xFF
        self.sp = (self.sp + 1) & 0xFF

    def pop(self):
        self.sp = (self.sp - 1) & 0xFF
        return self.stack[self.sp]

    def peek(self, offset=0):
        idx = (self.sp - 1 - offset) & 0xFF
        return self.stack[idx]

    def run(self, max_steps=100000, trace=False):
        steps = 0
        while not self.halt and steps < max_steps:
            if self.ip >= self.max_ip:
                self.halt = True
                break

            opcode = self.bytecode[self.ip]
            old_ip = self.ip

            if trace:
                print(f"  IP={self.ip:04x} OP={opcode:02x} SP={self.sp} stack_top={self.stack[(self.sp-1)&0xff]:02x}")

            if opcode == 0x00:
                # NOP
                self.ip += 1

            elif opcode == 0x01:
                # PUSH immediate
                val = self.bytecode[self.ip + 1]
                self.push(val)
                self.ip += 2

            elif opcode == 0x02:
                # POP to register
                reg = self.bytecode[self.ip + 1] & 7
                val = self.pop()
                self.regs[reg] = val
                self.ip += 2

            elif opcode == 0x03:
                # PUSH register
                reg = self.bytecode[self.ip + 1] & 7
                self.push(self.regs[reg])
                self.ip += 2

            elif opcode == 0x04:
                # POP to memory
                addr = self.bytecode[self.ip + 1]
                val = self.pop()
                self.mem[addr] = val
                self.ip += 2

            elif opcode == 0x05:
                # PUSH from memory
                addr = self.bytecode[self.ip + 1]
                self.push(self.mem[addr])
                self.ip += 2

            elif opcode == 0x10:
                # ADD
                a = self.pop()
                b = self.pop()
                self.push((a + b) & 0xFF)
                self.ip += 1

            elif opcode == 0x11:
                # SUB: second - top
                top = self.pop()
                second = self.pop()
                self.push((second - top) & 0xFF)
                self.ip += 1

            elif opcode == 0x12:
                # XOR
                top = self.pop()
                second = self.pop()
                result = (top ^ second ^ self.xor_global) & 0xFF
                self.push(result)
                self.ip += 1

            elif opcode == 0x13:
                # AND
                top = self.pop()
                second = self.pop()
                self.push((top & second) & 0xFF)
                self.ip += 1

            elif opcode == 0x14:
                # OR
                top = self.pop()
                second = self.pop()
                self.push((top | second) & 0xFF)
                self.ip += 1

            elif opcode == 0x20:
                # CMP EQ
                top = self.pop()
                second = self.pop()
                self.push(1 if top == second else 0)
                self.ip += 1

            elif opcode == 0x30:
                # JUMP unconditional
                lo = self.bytecode[self.ip + 1]
                hi = self.bytecode[self.ip + 2]
                self.ip = lo | (hi << 8)

            elif opcode == 0x31:
                # JUMP IF ZERO
                val = self.pop()
                lo = self.bytecode[self.ip + 1]
                hi = self.bytecode[self.ip + 2]
                if val == 0:
                    self.ip = lo | (hi << 8)
                else:
                    self.ip += 3

            elif opcode == 0x32:
                # JUMP IF NONZERO
                val = self.pop()
                lo = self.bytecode[self.ip + 1]
                hi = self.bytecode[self.ip + 2]
                if val != 0:
                    self.ip = lo | (hi << 8)
                else:
                    self.ip += 3

            elif opcode == 0x40:
                # READ from stdin
                if self.input_buf:
                    ch = self.input_buf.pop(0)
                else:
                    ch = 0  # EOF -> 0
                self.push(ch)
                self.ip += 1

            elif opcode == 0x41:
                # WRITE to stdout
                val = self.pop()
                self.output.append(val)
                self.ip += 1

            elif opcode == 0x91:
                # This appears as part of bytecode patterns. Let me check.
                # 0x91 doesn't match any handler - it goes to default (HALT)
                self.halt = True
                self.exit_code = 1

            elif opcode == 0xfe:
                # Also maps to default (HALT)
                self.halt = True
                self.exit_code = 0

            elif opcode == 0xff:
                # HALT
                self.halt = True
                self.exit_code = 0

            else:
                # Default handler: HALT
                self.halt = True
                self.exit_code = 1

            steps += 1

        return steps

# Analyze the bytecode structure
print("\n[*] Analyzing bytecode...")

# The first part is: read char, XOR with constant, compare, jump if not equal -> halt
# Pattern: 40 01 XX 12 01 YY 20 31 91 02
# This is: READ, PUSH XX, XOR, PUSH YY, CMP_EQ, JMP_IF_ZERO 0x0291
# Wait, 31 91 02 = JMP_IF_ZERO to address 0x91 | (0x02 << 8) = 0x0291

# Let's figure out: for each input char, what XOR value produces what expected result?
print("\n[*] Extracting character verifications...")

i = 0
expected_chars = []
while i < len(bytecode) - 9:
    if (bytecode[i] == 0x40 and bytecode[i+1] == 0x01 and
        bytecode[i+3] == 0x12 and bytecode[i+4] == 0x01 and
        bytecode[i+6] == 0x20 and bytecode[i+7] == 0x31):
        xor_val = bytecode[i+2]
        expected = bytecode[i+5]
        # READ char, PUSH xor_val, XOR -> result. PUSH expected, CMP_EQ
        # So: (input_char XOR xor_val) == expected
        # Therefore: input_char = expected XOR xor_val
        char_val = expected ^ xor_val
        expected_chars.append((i, xor_val, expected, char_val, chr(char_val) if 32 <= char_val < 127 else '?'))
        print(f"  Pos {len(expected_chars):2d} @ {i:04x}: input XOR 0x{xor_val:02x} == 0x{expected:02x} -> char = 0x{char_val:02x} = '{chr(char_val) if 32 <= char_val < 127 else '?'}'")
        i += 10
    else:
        i += 1

password = ''.join(c[4] for c in expected_chars)
print(f"\n[+] Password: {password}")

# Verify with emulator
print("\n[*] Verifying with emulator...")
vm = VM(bytecode, password.encode())
vm.run(trace=False)
output = bytes(vm.output).decode('ascii', errors='replace')
print(f"[*] Output: {output}")

# Also look at the second part of the bytecode (after the verifications)
# that generates output text
print("\n[*] Analyzing the output section...")
# The pattern 01 XX 01 YY 10 41 = PUSH XX, PUSH YY, ADD, WRITE
# What gets written is (XX + YY) & 0xFF

output_start = len(expected_chars) * 10  # After the verifications
print(f"  Output section starts at offset {output_start:04x}")

i = output_start
success_msg = []
while i < len(bytecode) - 5:
    if (bytecode[i] == 0x01 and bytecode[i+2] == 0x01 and
        bytecode[i+4] == 0x10 and bytecode[i+5] == 0x41):
        a = bytecode[i+1]
        b = bytecode[i+3]
        ch = (a + b) & 0xFF
        success_msg.append(chr(ch) if 32 <= ch < 127 else '?')
        i += 6
    elif bytecode[i] == 0xfe or bytecode[i] == 0xff:
        break
    else:
        i += 1

print(f"  Success message: {''.join(success_msg)}")
